<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan">
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="ClackyAi-Issue-Thread-Test-hmj">
        <stringProp name="ThreadGroup.num_threads">${__P(threads, 1)}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">${__P(rampup, 0)}</stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="* User Defined Variables">
          <collectionProp name="Arguments.arguments">
            <elementProp name="PAAS_DOMAIN" elementType="Argument">
              <stringProp name="Argument.name">PAAS_DOMAIN</stringProp>
              <stringProp name="Argument.value">develop.clackypaas.com</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="BACKEND_DOMAIN" elementType="Argument">
              <stringProp name="Argument.name">BACKEND_DOMAIN</stringProp>
              <stringProp name="Argument.value">develop.api.clackyai.com</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="connectionID" elementType="Argument">
              <stringProp name="Argument.name">connectionID</stringProp>
              <stringProp name="Argument.value">${__Random(111111,999999,)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="wssOrigin" elementType="Argument">
              <stringProp name="Argument.name">wssOrigin</stringProp>
              <stringProp name="Argument.value">http://localhost:3010</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="repositoryId" elementType="Argument">
              <stringProp name="Argument.name">repositoryId</stringProp>
              <stringProp name="Argument.value">0196766e-dd28-78be-92d2-b6cf15c12666</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="workspaceId" elementType="Argument">
              <stringProp name="Argument.name">workspaceId</stringProp>
              <stringProp name="Argument.value">0191e5ad-2b22-7f7a-a905-d9ddb7015d4f</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="WSS_AGENT_DOMAIN" elementType="Argument">
              <stringProp name="Argument.name">WSS_AGENT_DOMAIN</stringProp>
              <stringProp name="Argument.value">develop.agent.clackyai.com</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="myProjectId" elementType="Argument">
              <stringProp name="Argument.name">myProjectId</stringProp>
              <stringProp name="Argument.value">0196c34f-a95d-7e6a-9d29-54345bea029e</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="myThreadId" elementType="Argument">
              <stringProp name="Argument.name">myThreadId</stringProp>
              <stringProp name="Argument.value">0196c34f-c1ce-7421-9fb4-7c64d5c77c81</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="threadId" elementType="Argument">
              <stringProp name="Argument.name">threadId</stringProp>
              <stringProp name="Argument.value">01981764-dbd1-751a-aa67-88af10549fd3</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="projectId" elementType="Argument">
              <stringProp name="Argument.name">projectId</stringProp>
              <stringProp name="Argument.value">01981764-ca1b-7363-b622-c33503df870f</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="testIssuePlaygroundId" elementType="Argument">
              <stringProp name="Argument.name">testIssuePlaygroundId</stringProp>
              <stringProp name="Argument.value">796579553765138432</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="testRootPlaygroundId" elementType="Argument">
              <stringProp name="Argument.name">testRootPlaygroundId</stringProp>
              <stringProp name="Argument.value">796579553765138432</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="pingCount" elementType="Argument">
              <stringProp name="Argument.name">pingCount</stringProp>
              <stringProp name="Argument.value">0</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="pingCountMax" elementType="Argument">
              <stringProp name="Argument.name">pingCountMax</stringProp>
              <stringProp name="Argument.value">3</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="token" elementType="Argument">
              <stringProp name="Argument.name">token</stringProp>
              <stringProp name="Argument.value">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkUVNLZ2s2WVl2N1lmVXZQSUhERDN5WGxISnVJbUs5ayIsImV4cCI6MTc1MzUxMDg3NCwibmJmIjoxNzUzNDI0NDc0LCJpYXQiOjE3NTM0MjQ0NzQsInN1YiI6IjAxOTFlNWFkLTJiMWItN2Y3YS1iMDdjLTA2ZjIwZjYyNTkzYyJ9.VMNemntul_Ekeao8wRK9plTHhoGG0a7orudiONmRxMc</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="parentCodezoneId" elementType="Argument">
              <stringProp name="Argument.name">parentCodezoneId</stringProp>
              <stringProp name="Argument.value">817526441024675840</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="* HTTP Header Manager">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="userId" elementType="Header">
              <stringProp name="Header.name">userId</stringProp>
              <stringProp name="Header.value">1</stringProp>
            </elementProp>
            <elementProp name="Authorization" elementType="Header">
              <stringProp name="Header.name">Authorization</stringProp>
              <stringProp name="Header.value">Bearer eyJhbGciOiJSUzI1NiIsImNhdCI6ImNsX0I3ZDRQRDIyMkFBQSIsImtpZCI6Imluc18yamxoTFNvTVBpdWMxeUlCNFdKOHByb3QxbFUiLCJ0eXAiOiJKV1QifQ.eyJhenAiOiJodHRwczovL2RldmVsb3AuYXBwLmNsYWNreWFpLmNvbSIsImV4cCI6MTc1NDAyODgwOCwiaWF0IjoxNzUzNDI0MDA4LCJpc3MiOiJodHRwczovL3NvbGlkLW1hcnRpbi0xNS5jbGVyay5hY2NvdW50cy5kZXYiLCJqdGkiOiI3NjUyMDY3ZGU5NmNiZmU0MTgyNyIsIm5iZiI6MTc1MzQyNDAwMywic3ViIjoidXNlcl8ybHh3cE1qNE92eVVsTTZFYW56NWVDMjAwdjkifQ.ddXTHxQK6UZD5VDQxotzYSNGTexwEBdwfDyf3vhuh-pBG_rxcU4vs3xQOHl14J2H2gxUfC6wOqOPea4PXh6SU2hmT8Zb6aU139YcwAuiFB4I7yzAA8hYPI53chIW0FinpO_B5m6BZw2838u5Db1NCEx97zYtUzdGNfJ68tMfPaikEfbuJ8AwoO_fpIWiprGeurIAMGOrYbmXeMJVWa4u2UwqsYrTI-fpdAneq3okNMdBIghShyLvfPQtwqMtuQuaBQtLhs5US9cJSReJoSA1eUSs3rjHu_LQq32qork8zRsj7pBn-GyeOYuZEi4OI-dHl59zoxvg13i1hPl-y2VSeg</stringProp>
            </elementProp>
            <elementProp name="Workspace-Id" elementType="Header">
              <stringProp name="Header.name">Workspace-Id</stringProp>
              <stringProp name="Header.value">${workspaceId}</stringProp>
            </elementProp>
            <elementProp name="Project-ID" elementType="Header">
              <stringProp name="Header.name">Project-ID</stringProp>
              <stringProp name="Header.value">${projectId}</stringProp>
            </elementProp>
            <elementProp name="Thread-ID" elementType="Header">
              <stringProp name="Header.name">Thread-ID</stringProp>
              <stringProp name="Header.value">${threadId}</stringProp>
            </elementProp>
            <elementProp name="tenantCode" elementType="Header">
              <stringProp name="Header.name">tenantCode</stringProp>
              <stringProp name="Header.value">demo</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="* 日志函数定义 - LogInfo Function">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import java.text.SimpleDateFormat;
import java.util.Date;

// 直接定义一个简单的logInfo方法（避免类和静态方法的复杂性）
Object traceInfo(customMessage,type) {
    // 创建时间格式化器
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
    String timestamp = sdf.format(new Date());
    
    // 获取任务名称和相关上下文变量
    String taskName = vars.get(&quot;taskName&quot;) != null ? vars.get(&quot;taskName&quot;) : &quot;UNKNOWN_TASK&quot;;
    String playgroundId = vars.get(&quot;issueThreadPlaygroundId&quot;) != null ? vars.get(&quot;issueThreadPlaygroundId&quot;) : &quot;N/A&quot;;
    String issueThreadCodezoneId = vars.get(&quot;issueThreadCodezoneId&quot;) != null ? vars.get(&quot;issueThreadCodezoneId&quot;) : &quot;N/A&quot;;
    
    // 获取采样器信息
    String sampler = &quot;N/A&quot;;
    String success = &quot;N/A&quot;;
    String statusCode = &quot;N/A&quot;;
    
    // 安全地获取前一个采样器的信息
    if (prev != null) {
        sampler = prev.getSampleLabel() != null ? prev.getSampleLabel() : &quot;N/A&quot;;
        success = prev.isSuccessful() ? &quot;SUCCESS&quot; : &quot;FAIL&quot;;
        statusCode = prev.getResponseCode() != null ? prev.getResponseCode() : &quot;N/A&quot;;
    }
    
    // 获取线程信息
    int threadNum = ctx.getThreadNum();
    String threadName = Thread.currentThread().getName();
    
    // 构建完整的日志消息
    String logMessage = &quot;TraceLog &quot;+ type +&quot; Task: &quot; + threadName + &quot; | Sampler: &quot; + sampler + 
                       &quot; | issueThreadCodezoneId: &quot; + issueThreadCodezoneId + &quot;,PlaygroundId: &quot; + playgroundId ;
    
    // 如果有自定义消息，添加到日志中
    if (customMessage != null &amp;&amp; !customMessage.trim().isEmpty()) {
        logMessage += &quot; | Message: &quot; + customMessage;
    }
    
    if(type == &quot;error&quot;){
	  log.error(logMessage);
    	}else{
    	  log.info(logMessage);
    	}
    return logMessage;
}

// 直接定义一个简单的logInfo方法（避免类和静态方法的复杂性）
Object traceInfo(customMessage,type, Throwable e) {
    // 创建时间格式化器
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
    String timestamp = sdf.format(new Date());
    
    // 获取任务名称和相关上下文变量
    String taskName = vars.get(&quot;taskName&quot;) != null ? vars.get(&quot;taskName&quot;) : &quot;UNKNOWN_TASK&quot;;
    String playgroundId = vars.get(&quot;issueThreadPlaygroundId&quot;) != null ? vars.get(&quot;issueThreadPlaygroundId&quot;) : &quot;N/A&quot;;
    String issueThreadCodezoneId = vars.get(&quot;issueThreadCodezoneId&quot;) != null ? vars.get(&quot;issueThreadCodezoneId&quot;) : &quot;N/A&quot;;
    
    // 获取采样器信息
    String sampler = &quot;N/A&quot;;
    String success = &quot;N/A&quot;;
    String statusCode = &quot;N/A&quot;;
    
    // 安全地获取前一个采样器的信息
    if (prev != null) {
        sampler = prev.getSampleLabel() != null ? prev.getSampleLabel() : &quot;N/A&quot;;
        success = prev.isSuccessful() ? &quot;SUCCESS&quot; : &quot;FAIL&quot;;
        statusCode = prev.getResponseCode() != null ? prev.getResponseCode() : &quot;N/A&quot;;
    }
    
    // 获取线程信息
    int threadNum = ctx.getThreadNum();
    String threadName = Thread.currentThread().getName();
    
    // 构建完整的日志消息
    String logMessage = &quot;TraceLog &quot;+ type +&quot; Task: &quot; + threadName + &quot; | Sampler: &quot; + sampler + 
                       &quot; | issueThreadCodezoneId: &quot; + issueThreadCodezoneId + &quot;,PlaygroundId: &quot; + playgroundId ;
    
    // 如果有自定义消息，添加到日志中
    if (customMessage != null &amp;&amp; !customMessage.trim().isEmpty()) {
        logMessage += &quot; | Message: &quot; + customMessage;
    }
    
    if(type == &quot;error&quot;){
	    log.error(logMessage,e);
    	}else{
    	  log.info(logMessage);
    	}
    return logMessage;
}

Object info(customMessage) {
    traceInfo(customMessage,&quot;info&quot;);
    return customMessage;
}

Object error(customMessage) {
    traceInfo(customMessage,&quot;error&quot;);
    return customMessage;
}

Object error(customMessage, Throwable e) {
    traceInfo(customMessage,&quot;error&quot;);
    return customMessage;
}

if (bsh.shared.util == void) {
    bsh.shared.util = this;
}
</stringProp>
        </BeanShellPreProcessor>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="* LogInfo 使用示例" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// ===========================================
// logInfo函数使用示例 - 复制此代码到任何BeanShell脚本中使用
// ===========================================

// 基本用法 - 记录简单信息
bsh.shared.logInfo(&quot;开始执行某个业务逻辑&quot;);

// 记录处理过程
bsh.shared.logInfo(&quot;正在处理用户ID: &quot; + vars.get(&quot;userId&quot;));

// 记录成功信息
bsh.shared.logInfo(&quot;数据解析成功，提取到关键字段: someValue&quot;);

// 记录错误信息
bsh.shared.logInfo(&quot;处理失败，错误原因: 响应状态不正确&quot;);

// 记录调试信息
bsh.shared.logInfo(&quot;当前变量状态 - playgroundId: &quot; + vars.get(&quot;playgroundId&quot;) + &quot;, codezoneId: &quot; + vars.get(&quot;issueThreadCodezoneId&quot;));

// 记录业务流程节点
bsh.shared.logInfo(&quot;进入业务流程: 创建playground&quot;);
bsh.shared.logInfo(&quot;完成业务流程: 创建playground&quot;);

// ===========================================
// 函数优势：
// 1. 自动包含时间戳、任务名称、线程信息等上下文
// 2. 自动获取采样器名称、状态、响应码等信息  
// 3. 统一的日志格式，便于日志分析和问题排查
// 4. 只需传入自定义消息即可，其他信息自动填充
// ===========================================</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="公共业务流程" enabled="false"/>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [Backend] 获取用户信息 /auth/account" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/auth/account</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;first_name&quot;: &quot;bb_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;,&#xd;
    &quot;last_name&quot;: &quot;bb_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;,&#xd;
    &quot;gender&quot;: &quot;female&quot;,&#xd;
    &quot;image_url&quot;: &quot;https://baidu.com&quot;,&#xd;
    &quot;username&quot;: &quot;136_${__time(yyyyMMddHHmmss,)}_${__threadNum}_${__Random(111111,999999,)}&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增]  [Backend] 创建 workspacke /workspace" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/workspace</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
	&quot;workspace_name&quot;: &quot;workspacet_test_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">content-type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [Backend]   [Backend] 查看密钥 /ssh/key/list" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/ssh/key/list</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">content-type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增]  [Backend] 通知列表 /notification/list" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/notification/list</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增][Backend] 站内信已读 /notification/read-all" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/notification/read-all</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] wokspace 列表 /workspace/list" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/workspace/list</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] 项目列表 /project/list" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/project/list</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value"></stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] 仓库列表 /integration/repository/list" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/integration/repository/list</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] 获取最近项目 /project/recent" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/project/recent</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] 项目详情 /project/detail" enabled="false">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/project/detail</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] 创建人列表 /thread/creator-list" enabled="false">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/creator-list</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] thread 列表 /thread/list" enabled="false">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/list</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="连接 rootThread 制定需求" enabled="false"/>
        <hashTree>
          <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="[AI] 连接 rootThread" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${testRootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="readTimeout">60000</stringProp>
          </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] isRoot" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">40{&quot;playgroundId&quot;:&quot;799763908452847616&quot;,&quot;isRoot&quot;:true,&quot;projectId&quot;:&quot;01971af3-df3f-73cb-bc66-e52687c89e55&quot;,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkUVNLZ2s2WVl2N1lmVXZQSUhERDN5WGxISnVJbUs5ayIsImV4cCI6MTc0ODU5MjA0NiwibmJmIjoxNzQ4NTA1NjQ2LCJpYXQiOjE3NDg1MDU2NDYsInN1YiI6IjAxOTFkOWZjLWVhOGUtNzdlOC1iMGI4LTA1YzAyZTE4ZjdiZiJ9.MZnY5wlqGzBvmSPTTvQX9VCrnOVqqCtXMHJOBxbxzCs&quot;}</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] 发消息制定需求" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;message&quot;,&quot;实现冒泡排序&quot;,false,true]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="[AI] 监听需求制定并解析签名数据、任务规模、建议分支等" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount&quot;)) &lt; 200 &amp;&amp; vars.get(&quot;monitorFlagSpecUpdated&quot;) == null),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="[AI] 监听需求制定并解析签名数据、任务规模、建议分支等" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="analyze specUpdate response" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;specUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 specUpdated 消息&quot;);
				 vars.put(&quot;monitorFlagSpecUpdated&quot;, &quot;specUpdated&quot;);
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="WebSocket Close" enabled="true">
            <stringProp name="statusCode">1000</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
          </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[New]  [Backend] caculate credit /credit/calculate">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/credit/calculate</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments">
              <elementProp name="scene" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">thread</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">scene</stringProp>
              </elementProp>
              <elementProp name="demand_scale" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">micro</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">demand_scale</stringProp>
              </elementProp>
              <elementProp name="sign_data" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">true</boolProp>
                <stringProp name="Argument.value">{&quot;ciphertext&quot;: &quot;iYWoETHL8lXbOtsq3xyXAe+4DV4aQrW7BJY9w7zk1QyNQAOVWBqouEvpqmwo/FI+1QGPfe93DQxD3lHpqdHjTtkXR4KpXG9xHjpX9m0lWZ9OJFuCPcsITrIjsdmcmzeyNfbNFM3U&quot;, &quot;nonce&quot;: &quot;Azf92WYO4YoHmFib&quot;, &quot;tag&quot;: &quot;ivmlXYaok32+c/8k7wlXzg==&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">sign_data</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager">
            <collectionProp name="HeaderManager.headers"/>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] create issue thread /thread/create-another">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/create-another</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
	&quot;workspace_id&quot;: &quot;${workspaceId}&quot;,&#xd;
	&quot;project_id&quot;: &quot;${projectId}&quot;,&#xd;
	&quot;name&quot;: &quot;implement popular sort&quot;,&#xd;
	&quot;branch&quot;: &quot;feat/implement-sort_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;,&#xd;
	&quot;thread_type&quot;: &quot;NORMAL&quot;,&#xd;
	&quot;is_bind_url&quot;: 0,&#xd;
	&quot;parent_thread_id&quot;: null,&#xd;
	&quot;issue&quot;: &quot;{\&quot;goal\&quot;:\&quot;Add update time to README file\&quot;,\&quot;goal_detail\&quot;:\&quot;Add an update time section to the existing README.md file. The current README only contains a title paas_demo_go21. Need to add a timestamp or last updated section to track when the README was last modified. This could be in the format of a Last Updated section with the current date, or a timestamp format that can be easily maintained.\&quot;,\&quot;current_list\&quot;:[\&quot;The README.md file currently only contains the title &apos;# paas_demo_go21&apos;.\&quot;,\&quot;There is no mechanism to track the last update time of the README.md file.\&quot;],\&quot;proposed_list\&quot;:[\&quot;Add a &apos;Last Updated&apos; section to the README.md file.\&quot;,\&quot;Include the current date or a timestamp in the &apos;Last Updated&apos; section.\&quot;]}&quot;,&#xd;
	&quot;pay_info&quot;: {&#xd;
		&quot;scene&quot;: &quot;thread&quot;,&#xd;
		&quot;demand_scale&quot;: &quot;micro&quot;,&#xd;
		&quot;demand_id&quot;: &quot;2e8cc9cd-c5b3-4d40-ad33-c2d02040d99d&quot;,&#xd;
		&quot;sign_data&quot;: &quot;j4hV8keDnzJAe5WhYqPfhQsYUi2bJ8lMHwpt0Dg4xlAQ3JY75BBijw5rorS5f31ylcqacrJHOz5tSdLSSrCWheRVyPZMxJbMxrBDk7a8G0Ge0o/IGFUthpPtwrW4UU8Kj0APRNOC&quot;,&#xd;
		&quot;credit&quot;: 100,&#xd;
		&quot;nonce&quot;: &quot;bCXkn0Z4vSGyRdqW&quot;,&#xd;
		&quot;tag&quot;: &quot;HdOpQ8I+DLBOZc/nuDmENw==&quot;,&#xd;
		&quot;timestamp&quot;: 1749111338014&#xd;
	}&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize issueThreadId and branch">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();
bsh.shared.util.info(&quot;原始响应数据: &quot; + jsonResult);

// 创建 JSONObject 解析响应
JSONObject jsonObject = new JSONObject(jsonResult);

// 检查 code 和 msg
int code = jsonObject.getInt(&quot;code&quot;);
String msg = jsonObject.getString(&quot;msg&quot;);
bsh.shared.util.info(&quot;code: &quot; + code);
bsh.shared.util.info(&quot;msg: &quot; + msg);

// 如果响应成功 (code=200 且 msg=&quot;Succeed&quot;)
if (code == 200 &amp;&amp; &quot;Succeed&quot;.equals(msg)) {
    // 提取 data 对象中的 id
    JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
    String issueThreadId = data.getString(&quot;id&quot;);
    String issueThreadBranch = data.getString(&quot;branch&quot;);
    
    bsh.shared.util.info(&quot;解析到的 issueThreadId: &quot; + issueThreadId);
    // 将 id 存入 JMeter 变量中
    vars.put(&quot;issueThreadId&quot;, issueThreadId);
    vars.put(&quot;issueThreadBranch&quot;, issueThreadBranch);
} else {
    bsh.shared.util.error(&quot;响应未成功，无法提取 issueThreadId&quot;);
    prev.setStopTest(true);
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] fetch /thread/fetch [ need close rootThread]">
          <stringProp name="TestPlan.comments">要求容器激活</stringProp>
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/fetch</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增][Backend] Enter /thread/enter">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/enter</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize  parentCodezoneId" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();
bsh.shared.util.info(&quot;原始响应数据: &quot; + jsonResult);

// 创建 JSONObject 解析响应
JSONObject jsonObject = new JSONObject(jsonResult);

// 检查 code 和 msg
int code = jsonObject.getInt(&quot;code&quot;);
String msg = jsonObject.getString(&quot;msg&quot;);
bsh.shared.util.info(&quot;code: &quot; + code);
bsh.shared.util.info(&quot;msg: &quot; + msg);

// 如果响应成功 (code=200 且 msg=&quot;Succeed&quot;)
if (code == 200 &amp;&amp; &quot;Succeed&quot;.equals(msg)) {
    // 提取 data 对象中的 id
    JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
    String parentCodezoneId = data.getString(&quot;parent_codezone_id&quot;);
    
    bsh.shared.util.info(&quot;解析到的 parentCodezoneId: &quot; + parentCodezoneId);
    // 将 id 存入 JMeter 变量中
    vars.put(&quot;parentCodezoneId&quot;, parentCodezoneId);
} else {
    bsh.shared.util.error(&quot;响应未成功，无法提取 parent_codezone_id&quot;);
    prev.setStopTest(true);
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[PaaS] fork codezone">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/fork</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
	&quot;codeZoneId&quot;: &quot;${parentCodezoneId}&quot;,&#xd;
	&quot;commitId&quot;: &quot;&quot;,&#xd;
	&quot;withMiddlewareData&quot;: true,&#xd;
	&quot;purpose&quot;: &quot;2-stress-test&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="[paas template] anaylize  issueThreadId issueThread codezoneId">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();
bsh.shared.util.info(&quot;原始响应数据: &quot; + jsonResult);

// 创建 JSONObject 解析响应
JSONObject jsonObject = new JSONObject(jsonResult);

// 检查 status
String status = jsonObject.getString(&quot;status&quot;);
bsh.shared.util.info(&quot;status: &quot; + status);

// 如果响应成功 ( status=&quot;success&quot;)
if ( &quot;success&quot;.equals(status)) {
    // 提取 data 对象中的 id
    JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
    String issueThreadCodezoneId = data.getString(&quot;id&quot;);
    
    bsh.shared.util.info(&quot;解析到的 issueThreadCodezoneId: &quot; + issueThreadCodezoneId);
    // 将 id 存入 JMeter 变量中
    vars.put(&quot;issueThreadCodezoneId&quot;, issueThreadCodezoneId);
} else {
    bsh.shared.util.error(&quot;响应未成功，无法提取 issueThreadCodezoneId&quot;);
    prev.setStopTest(true);
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend update issueThread 状态和 codezoneId">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;id&quot;: &quot;${issueThreadId}&quot;,&#xd;
  &quot;codezone_id&quot;: &quot;${issueThreadCodezoneId}&quot;,&#xd;
  &quot;workspace_id&quot;: &quot;${workspaceId}&quot;,&#xd;
  &quot;project_id&quot;: &quot;${projectId}&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="mock fork codezone interface" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.apache.jmeter.threads.JMeterContextService;

// 定义你的业务ID列表（数组）
String[] codezone_ids = {

&quot;803698475706482688&quot;,
&quot;804170926345347072&quot;,
&quot;804170865808957440&quot;,
&quot;804168622640697344&quot;,
&quot;804176500076240896&quot;,
&quot;804170945307840512&quot;,
&quot;802667887725772800&quot;,
&quot;804125356549443584&quot;,
&quot;804168716848914432&quot;,
&quot;802693111888347136&quot;,
&quot;802667885213700096&quot;,
&quot;804168973431267328&quot;,
&quot;804142147791196160&quot;,
&quot;802731949956714496&quot;,
&quot;804214121959968768&quot;,
&quot;804213905844047872&quot;,
&quot;804161503048732672&quot;,
&quot;804214154079735808&quot;,
&quot;804125341407961088&quot;,
&quot;804161525786054656&quot;,
&quot;804214193795600384&quot;,
&quot;804214009552621568&quot;,
&quot;804161453753032704&quot;,
&quot;804125268435460096&quot;,
&quot;804176705181945856&quot;,
&quot;804176505826631680&quot;,
&quot;804507202903003136&quot;,
&quot;804125233345957888&quot;,
&quot;804213967324368896&quot;,
&quot;804170899438931968&quot;,
&quot;804125316317679616&quot;,
&quot;802667876686680064&quot;,
&quot;804213979500220416&quot;,
&quot;804214207880073216&quot;,
&quot;804176468170170368&quot;,
&quot;802716791196798976&quot;,
&quot;802731979199086592&quot;,
&quot;804214002732683264&quot;,
&quot;802678350518079488&quot;,
&quot;804170959149043712&quot;,
&quot;804168677309210624&quot;,
&quot;804169150896508928&quot;,
&quot;804509701697146880&quot;,
&quot;802685274756141056&quot;,
&quot;804176649200570368&quot;,
&quot;804170948772335616&quot;,
&quot;804176445990735872&quot;,
&quot;802693109849915392&quot;,
&quot;804170874801545216&quot;,
&quot;804168952916926464&quot;,
&quot;804161468168900608&quot;,
&quot;804170959534874624&quot;,
&quot;804125422047694848&quot;,
&quot;804170877754380288&quot;,
&quot;804213926375165952&quot;,
&quot;804175965428355072&quot;,
&quot;804125253457600512&quot;,
&quot;804214054163238912&quot;,
&quot;804125364032036864&quot;,
&quot;804170954094907392&quot;,
&quot;804170923434545152&quot;,
&quot;804045094117310464&quot;,
&quot;802692967788838912&quot;,
&quot;804201225808744448&quot;,
&quot;804117415532613632&quot;,
&quot;804176546993725440&quot;,
&quot;804214709682409472&quot;,
&quot;804161555347464192&quot;,
&quot;776912878229131264&quot;,
&quot;804168649672941568&quot;,
&quot;804176494455873536&quot;,
&quot;804168667398070272&quot;,
&quot;804161551044108288&quot;,
&quot;804175961640898560&quot;,
&quot;802722838695301120&quot;,
&quot;804501865902608384&quot;,
&quot;802716783604793344&quot;,
&quot;804214104377233408&quot;,
&quot;804168684934500352&quot;,
&quot;802600386614657024&quot;,
&quot;802693120834797568&quot;,
&quot;804161515770011648&quot;,
&quot;802716780052533248&quot;,
&quot;802577804741967872&quot;,
&quot;804170952618467328&quot;,
&quot;804213901628772352&quot;,
&quot;804168672368365568&quot;,
&quot;802731984492298240&quot;,
&quot;804176033476743168&quot;,
&quot;804170870523400192&quot;,
&quot;802663359123161088&quot;,
&quot;802716782103547904&quot;,
&quot;804168619834662912&quot;,
&quot;804213983522770944&quot;,
&quot;804170941843300352&quot;,
&quot;804177020601950208&quot;,
&quot;802716791989522432&quot;,
&quot;804482810311528448&quot;,
&quot;804170940689866752&quot;,
&quot;804125243416436736&quot;,
&quot;804487724467146752&quot;,
&quot;802663356820803584&quot;,
&quot;802649413863788544&quot;,
&quot;802716780773638144&quot;,
&quot;804213970012917760&quot;,
&quot;804161533830684672&quot;,
&quot;804214027613081600&quot;,
&quot;804213929143406592&quot;,
&quot;804125444587839488&quot;,
&quot;804125346562805760&quot;,
&quot;788944102971641856&quot;,
&quot;804170959060918272&quot;,
&quot;802716783248277504&quot;,
&quot;802716786763104256&quot;,
&quot;802680980535431168&quot;,
&quot;804176017337061376&quot;,
&quot;802693109774417920&quot;,
&quot;804213922357235712&quot;,
&quot;802663358544347136&quot;,
&quot;804170871525793792&quot;,
&quot;804125323833872384&quot;,
&quot;804102301462691840&quot;,
&quot;804161474112184320&quot;,
&quot;804214035544723456&quot;,
&quot;804171799167426560&quot;,
&quot;804213914207703040&quot;,
&quot;804176367389478912&quot;,
&quot;804176544502353920&quot;,
&quot;804170944531894272&quot;,
&quot;804169095410016256&quot;,
&quot;802693121896271872&quot;,
&quot;804171807912550400&quot;,
&quot;804168705608224768&quot;,
&quot;804171801818271744&quot;,
&quot;802722859167383552&quot;,
&quot;804168700008783872&quot;,
&quot;804170930015363072&quot;,
&quot;804161459180462080&quot;,
&quot;804214093547540480&quot;,
&quot;804170889905233920&quot;,
&quot;804125276085870592&quot;,
&quot;804214168969728000&quot;,
&quot;804213907463049216&quot;,
&quot;804177058497486848&quot;,
&quot;804170916148994048&quot;,
&quot;804213984961204224&quot;,
&quot;804125245895315456&quot;,
&quot;804170901288574976&quot;,
&quot;804170898633625600&quot;,
&quot;804214034340745216&quot;,
&quot;802716779612131328&quot;,
&quot;804213908566364160&quot;,
&quot;804170935874850816&quot;,
&quot;804170943600758784&quot;,
&quot;804161548988899328&quot;,
&quot;804168958587670528&quot;,
&quot;804117407105941504&quot;,
&quot;804170920351731712&quot;,
&quot;804168682342375424&quot;,
&quot;804175978078330880&quot;,
&quot;804513181925085184&quot;,
&quot;802716790454407168&quot;,
&quot;804175996222889984&quot;,
&quot;802731941987221504&quot;,
&quot;804475454055960576&quot;,
&quot;804177177766715392&quot;,
&quot;804213919719018496&quot;,
&quot;804214217183039488&quot;,
&quot;804176016028438528&quot;,
&quot;802722845682696192&quot;,
&quot;804125381765599232&quot;,
&quot;804175970885144576&quot;,
&quot;804125228379856896&quot;,
&quot;804161475538247680&quot;,
&quot;802667882407395328&quot;,
&quot;804214028883955712&quot;,
&quot;802722880361201664&quot;,
&quot;804214098857742336&quot;,
&quot;804125336395767808&quot;,
&quot;802716787862011904&quot;,
&quot;804161485415833600&quot;,
&quot;804168969815777280&quot;,
&quot;804214182622187520&quot;,
&quot;804481183013638144&quot;,
&quot;804170889141915648&quot;,
&quot;804125283606257664&quot;,
&quot;804213963754803200&quot;,
&quot;804214139244695552&quot;,
&quot;804170900336467968&quot;,
&quot;802640661860974592&quot;,
&quot;804176478878273536&quot;,
&quot;802693126014763008&quot;,
&quot;804170868539494400&quot;,
&quot;804168945631465472&quot;,
&quot;804125226995781632&quot;,
&quot;802722853756731392&quot;,
&quot;804214066406199296&quot;,
&quot;804170885283110912&quot;,
&quot;802332322447151104&quot;,
&quot;804213930464825344&quot;,
&quot;804213993165262848&quot;,
&quot;804161562117070848&quot;,
&quot;804125372638748672&quot;,
&quot;802310364816605184&quot;,
&quot;803394065726361600&quot;,
&quot;804168793604677632&quot;,
&quot;802731940062035968&quot;,
&quot;802722876699889664&quot;,
&quot;804161540331900928&quot;,
&quot;804455791645347840&quot;,
&quot;804168950383566848&quot;,
&quot;802716782933704704&quot;,
&quot;804168958776369152&quot;,
&quot;804170873174200320&quot;,
&quot;804161495490551808&quot;,
&quot;804169095074471936&quot;,
&quot;804214077407858688&quot;,
&quot;804170953507659776&quot;,
&quot;804161497990356992&quot;,
&quot;804170886260428800&quot;,
&quot;804161504365744128&quot;,
&quot;804510448287453184&quot;,
&quot;804213990502092800&quot;,
&quot;804175989327454208&quot;,
&quot;804168791247478784&quot;,
&quot;804170887980048384&quot;,
&quot;804170958561796096&quot;,
&quot;802722857720664064&quot;,
&quot;802667880860012544&quot;,
&quot;804214101592215552&quot;,
&quot;804125348999651328&quot;,
&quot;804169099918893056&quot;,
&quot;802693124756787200&quot;,
&quot;804214213647454208&quot;,
&quot;802663358624354304&quot;,
&quot;802653232236515328&quot;,
&quot;804170934905966592&quot;,
&quot;804125384202444800&quot;,
&quot;804176729626304512&quot;,
&quot;802722867300454400&quot;,
&quot;804503255035334656&quot;,
&quot;802656050372280320&quot;,
&quot;804161518223724544&quot;,
&quot;804125238379122688&quot;,
&quot;804170869227315200&quot;,
&quot;804214210111442944&quot;,
&quot;804170918283939840&quot;,
&quot;802716783315701760&quot;,
&quot;804102330181406720&quot;,
&quot;804125386840662016&quot;,
&quot;802722827802378240&quot;,
&quot;802716787484524544&quot;,
&quot;804214187022012416&quot;,
&quot;804214218437136384&quot;,
&quot;804170931957325824&quot;,
&quot;804161469066436608&quot;,
&quot;804171800853581824&quot;,
&quot;802722823839076352&quot;,
&quot;804214011007832064&quot;,
&quot;804125286038953984&quot;,
&quot;804214216465813504&quot;,
&quot;804214024975077376&quot;,
&quot;804125255919656960&quot;,
&quot;804170926198591488&quot;,
&quot;784277065808982016&quot;,
&quot;802722831971516416&quot;,
&quot;804201228178526208&quot;,
&quot;804175974827745280&quot;,
&quot;802716782036439040&quot;,
&quot;804168997070364672&quot;,
&quot;804161555448172544&quot;,
&quot;804213918385016832&quot;,
&quot;804168692408705024&quot;,
&quot;804170879503360000&quot;,
&quot;804161471784390656&quot;,
&quot;804175966716006400&quot;,
&quot;804170872691855360&quot;,
&quot;804213937498460160&quot;,
&quot;803397737537523712&quot;,
&quot;804214205346926592&quot;,
&quot;804170865066610688&quot;,
&quot;804161464226209792&quot;,
&quot;804176065911296000&quot;,
&quot;802685266241703936&quot;,
&quot;804125396739219456&quot;,
&quot;804213965977997312&quot;,
&quot;804170891054473216&quot;,
&quot;802722842889289728&quot;,
&quot;804161456579993600&quot;,
&quot;804213950169665536&quot;,
&quot;804213960147914752&quot;,
&quot;804214065257172992&quot;,
&quot;804214667911548928&quot;,
&quot;804234100247597056&quot;,
&quot;804472546442792960&quot;,
&quot;802731945217150976&quot;,
&quot;804169097792380928&quot;,
&quot;804050046889885696&quot;,
&quot;803388749198262272&quot;,
&quot;804170878706487296&quot;,
&quot;804168796200951808&quot;,
&quot;804170959933378560&quot;,
&quot;804168712960794624&quot;,
&quot;804056426787295232&quot;,
&quot;804168969119567872&quot;,
&quot;804214641717907456&quot;,
&quot;804170884326854656&quot;,
&quot;804213968771190784&quot;,
&quot;802722823750680576&quot;,
&quot;804170869797740544&quot;,
&quot;804161523202363392&quot;,
&quot;804161455497863168&quot;,
&quot;804170871458729984&quot;,
&quot;804213904506064896&quot;,
&quot;804170924374024192&quot;,
&quot;802716791599136768&quot;,
&quot;802685263666085888&quot;,
&quot;804214200598761472&quot;,
&quot;804214164922011648&quot;,
&quot;804214006704476160&quot;,
&quot;804175972323790848&quot;,
&quot;804161519360335872&quot;,
&quot;804125394226831360&quot;,
&quot;804493605594386432&quot;,
&quot;804214001327378432&quot;,
&quot;804176019824283648&quot;,
&quot;804170937997123584&quot;,
&quot;802680971773214720&quot;,
&quot;804170907919814656&quot;,
&quot;804170865880305664&quot;,
&quot;804176294991597568&quot;,
&quot;804475011070349312&quot;,
&quot;804214199139143680&quot;,
&quot;804214255003078656&quot;,
&quot;804171800924839936&quot;,
&quot;804176007589498880&quot;,
&quot;804125230778998784&quot;,
&quot;804161554240212992&quot;,
&quot;804213915629359104&quot;,
&quot;802685283257995264&quot;,
&quot;804218347507339264&quot;,
&quot;804161528298442752&quot;,
&quot;804201227738337280&quot;,
&quot;804234733763874816&quot;,
&quot;804213899909107712&quot;,
&quot;804214125113872384&quot;,
&quot;804170965436305408&quot;,
&quot;804170877209120768&quot;,
&quot;804214036643418112&quot;,
&quot;804125281068748800&quot;,
&quot;804208694857535488&quot;,
&quot;804176529356722176&quot;,
&quot;804161453815947264&quot;,
&quot;804125225510952961&quot;,
&quot;804175982222348288&quot;,
&quot;804170866534572032&quot;,
&quot;804176064401301504&quot;,
&quot;804175990694842368&quot;,
&quot;804176040246349824&quot;,
&quot;804170939762970624&quot;,
&quot;804213921031622656&quot;,
&quot;804161509356965888&quot;,
&quot;803417791121195008&quot;,
&quot;804176004674412544&quot;,
&quot;804176026811949056&quot;,
&quot;804170872192733184&quot;,
&quot;804170942807990272&quot;,
&quot;804125260990570496&quot;,
&quot;802731959330668544&quot;,
&quot;804214133494091776&quot;,
&quot;804214019312766976&quot;,
&quot;804168992016273408&quot;,
&quot;804176075444948992&quot;,
&quot;802722823494828032&quot;,
&quot;804161514406907904&quot;,
&quot;804168632048476160&quot;,
&quot;784965191795372032&quot;,
&quot;804214155577315328&quot;,
&quot;802731991509368832&quot;,
&quot;804170864521351168&quot;,
&quot;804170930241900544&quot;,
&quot;804170958498926592&quot;,
&quot;804213946210029568&quot;,
&quot;804176487233282048&quot;,
&quot;802716790550560768&quot;,
&quot;802716782820458496&quot;,
&quot;804125343958142976&quot;,
&quot;802716780345819136&quot;,
&quot;804213900244865024&quot;,
&quot;804214158060343296&quot;,
&quot;804177409166467072&quot;,
&quot;804214195305549824&quot;,
&quot;804125416905433088&quot;,
&quot;804125414397239296&quot;,
&quot;804169093354852352&quot;,
&quot;802731969393119232&quot;,
&quot;804170940912209920&quot;,
&quot;750825974282813440&quot;,
&quot;802667883695046656&quot;,
&quot;802680972700155904&quot;,
&quot;804214404026912768&quot;,
&quot;804214112480841728&quot;,
&quot;802731985822208000&quot;,
&quot;804125374396207104&quot;,
&quot;802678350102843392&quot;,
&quot;804214047489888256&quot;,
&quot;804170899568910336&quot;,
&quot;804213991710052352&quot;,
&quot;804213972919357440&quot;,
&quot;804213957467541504&quot;,
&quot;804170936080371712&quot;,
&quot;804168660343296000&quot;,
&quot;804170962257022976&quot;,
&quot;804161454206062592&quot;,
&quot;804214684537769984&quot;,
&quot;804213943295201280&quot;,
&quot;804169124505903104&quot;,
&quot;804169080407035904&quot;,
&quot;804161465459380224&quot;,
&quot;804214040695328768&quot;,
&quot;800160102727684096&quot;,
&quot;802644704272449536&quot;,
&quot;804214143723999232&quot;,
&quot;804161489283026944&quot;,
&quot;802722830524481536&quot;,
&quot;802680977565548544&quot;,
&quot;802656049927999488&quot;,
&quot;804170883341193216&quot;,
&quot;804213995870588928&quot;,
&quot;804170939922309120&quot;,
&quot;802667876950605824&quot;,
&quot;804170874218582016&quot;,
&quot;804214043291602944&quot;,
&quot;802353760616710144&quot;,
&quot;801632380472471552&quot;,
&quot;802731981854081024&quot;,
&quot;802731941417111552&quot;,
&quot;804170917319249920&quot;,
&quot;804214291791319040&quot;,
&quot;804168669839155200&quot;,
&quot;802731957951057920&quot;,
&quot;804170949774729216&quot;,
&quot;804475270252957696&quot;,
&quot;804171799272329216&quot;,
&quot;804161547097313280&quot;,
&quot;804214039537487872&quot;,
&quot;804170910562181120&quot;,
&quot;804176056578924544&quot;,
&quot;804169179099009024&quot;,
&quot;804214089571553280&quot;,
&quot;802731983158824960&quot;,
&quot;804214211847884800&quot;,
&quot;804177609209647104&quot;,
&quot;804214656490246144&quot;,
&quot;804125293584506880&quot;,
&quot;804176041492058112&quot;,
&quot;802693117756493824&quot;,
&quot;804214190863994880&quot;,
&quot;802731963713716224&quot;,
&quot;804168642160943104&quot;,
&quot;804214159486193664&quot;,
&quot;804125270981402624&quot;,
&quot;804176057937924096&quot;,
&quot;804170887032180736&quot;,
&quot;804213911275671552&quot;,
&quot;804169093761699840&quot;,
&quot;804169108517261312&quot;,
&quot;802722870039019520&quot;,
&quot;804168982516129792&quot;,
&quot;802731977928212480&quot;,
&quot;804512323258781696&quot;,
&quot;804169091333152768&quot;,
&quot;803422013049196544&quot;,
&quot;804125326337826816&quot;,
&quot;804161494270054400&quot;,
&quot;804214067840864256&quot;,
&quot;804125449621004288&quot;,
&quot;804214100300582912&quot;,
&quot;804214203408945152&quot;,
&quot;804170893575294976&quot;,
&quot;804169102808813568&quot;,
&quot;804210294749630464&quot;,
&quot;802731995536216064&quot;,
&quot;804040434774048768&quot;,
&quot;802666242677800960&quot;,
&quot;804170882540036096&quot;,
&quot;802722841358684160&quot;,
&quot;802731974979932160&quot;,
&quot;799775405031796736&quot;,
&quot;804170861702733824&quot;,
&quot;804102279757484032&quot;,
&quot;804170904052621312&quot;,
&quot;804213999977025536&quot;,
&quot;804213980708392960&quot;,
&quot;802693112417144832&quot;,
&quot;804117428194902016&quot;,
&quot;804168947959259136&quot;,
&quot;802685267675840512&quot;,
&quot;804176060567752704&quot;,
&quot;804170903075348480&quot;,
&quot;804125376870846464&quot;,
&quot;804170931185573888&quot;,
&quot;804213998810796032&quot;,
&quot;804177604121911296&quot;,
&quot;804213901192564736&quot;,
&quot;804214081556238336&quot;,
&quot;802722822182326272&quot;,
&quot;804168619784376320&quot;,
&quot;804161486711873536&quot;,
&quot;804170884490387456&quot;,
&quot;804496053637664768&quot;,
&quot;804214162120429568&quot;,
&quot;804176044298047488&quot;,
&quot;804223477334069248&quot;,
&quot;804176597744848896&quot;,
&quot;804102179660103680&quot;,
&quot;804170962168942592&quot;,
&quot;802385172048773120&quot;,
&quot;804170871030910976&quot;,
&quot;804170934125826048&quot;,
&quot;804170906191761408&quot;,
&quot;804468016304852992&quot;,
&quot;788950130920505344&quot;,
&quot;804161481670320128&quot;,
&quot;804171812983463936&quot;,
&quot;804170946062815232&quot;,
&quot;802716786310434816&quot;,
&quot;773974969834217472&quot;,
&quot;804176022508638208&quot;,
&quot;802722883087499264&quot;,
&quot;804170922209763328&quot;,
&quot;804168622556811264&quot;,
&quot;804214105748983808&quot;,
&quot;804214020520513536&quot;,
&quot;802730884456382464&quot;,
&quot;804176518866722816&quot;,
&quot;804213971375853568&quot;,
&quot;802693109481132032&quot;,
&quot;804213938937319424&quot;,
&quot;804170882401624064&quot;,
&quot;804214225345155072&quot;,
&quot;804176535622967296&quot;,
&quot;804125432290185216&quot;,
&quot;804214008118169600&quot;,
&quot;802716791703994368&quot;,
&quot;804214221247320064&quot;,
&quot;804214209075449856&quot;,
&quot;804170962693185536&quot;,
&quot;804125308809875456&quot;,
&quot;804213976761339904&quot;,
&quot;802375340374020096&quot;,
&quot;804473617592324096&quot;,
&quot;804125462191333376&quot;,
&quot;804214005417037824&quot;,
&quot;804504113919528960&quot;,
&quot;802716790848671744&quot;,
&quot;804170929113632768&quot;,
&quot;804214023821643776&quot;,
&quot;804102127118057472&quot;,
&quot;804170922868269056&quot;,
&quot;804170896536473600&quot;,
&quot;802666244909486080&quot;,
&quot;804161466709282816&quot;,
&quot;804214097796370432&quot;,
&quot;804214113965412352&quot;,
&quot;804481846942601216&quot;,
&quot;804214063881228288&quot;,
&quot;804170870930202624&quot;,
&quot;804213934558253056&quot;,
&quot;804170892585439232&quot;,
&quot;804168629628407808&quot;,
&quot;804170918086807552&quot;,
&quot;804448911577501696&quot;,
&quot;804170891843047424&quot;,
&quot;804176601444225024&quot;,
&quot;804170904249798656&quot;,
&quot;804170923308670976&quot;,
&quot;804214175789666304&quot;,
&quot;804214107065782272&quot;,
&quot;804214131958976512&quot;,
&quot;776266787582066688&quot;,
&quot;804161556928716800&quot;,
&quot;804171804511014912&quot;,
&quot;804214185474101248&quot;,
&quot;804176011402076160&quot;,
&quot;804095454303354880&quot;,
&quot;804161477878669312&quot;,
&quot;804214179845558272&quot;,
&quot;804176435945332736&quot;,
&quot;804171802279645184&quot;,
&quot;804170936847929344&quot;,
&quot;802663364097605632&quot;,
&quot;804214056835010560&quot;,
&quot;804213944603824128&quot;,
&quot;804472001451708416&quot;,
&quot;804214004229836800&quot;,
&quot;804214146093780992&quot;,
&quot;804214147394015232&quot;,
&quot;804170949921574912&quot;,
&quot;804168942879956992&quot;,
&quot;803786000777531392&quot;,
&quot;804214092083941376&quot;,
&quot;804214059812753408&quot;,
&quot;802722875412238336&quot;,
&quot;804170880602267648&quot;,
&quot;804161461567021056&quot;,
&quot;804214120621985792&quot;,
&quot;804214082835288064&quot;,
&quot;802731940490170368&quot;,
&quot;804485201198813184&quot;,
&quot;804449405016395776&quot;,
&quot;804170913435279360&quot;,
&quot;804125424681672704&quot;,
&quot;804161546996604928&quot;,
&quot;804161550297522176&quot;,
&quot;802731947402383360&quot;,
&quot;804175999058284544&quot;,
&quot;804168964736475136&quot;,
&quot;804125379328663552&quot;,
&quot;802685273208442880&quot;,
&quot;802722872702402560&quot;,
&quot;804214184098369536&quot;,
&quot;804213935917420544&quot;,
&quot;804125366577979392&quot;,
&quot;804161555754311680&quot;,
&quot;804170888957321216&quot;,
&quot;804170881436979200&quot;,
&quot;802685276157038592&quot;,
&quot;804096941821972480&quot;,
&quot;802667886777860096&quot;,
&quot;804214103081406464&quot;,
&quot;804176599774846976&quot;,
&quot;804176036341452800&quot;,
&quot;802722855136972800&quot;,
&quot;804170879675371520&quot;,
&quot;804168697576087552&quot;,
&quot;802644705006768128&quot;,
&quot;804229902592561152&quot;,
&quot;804168674809405440&quot;,
&quot;804213927843385344&quot;,
&quot;802654384507977728&quot;,
&quot;802680083709349888&quot;,
&quot;802680972046159872&quot;,
&quot;804170928329252864&quot;,
&quot;804175993542729728&quot;,
&quot;804169008332115968&quot;,
&quot;804214130558291968&quot;,
&quot;804171801054863360&quot;,
&quot;804170864982724608&quot;,
&quot;746549509051846656&quot;,
&quot;802685270448590848&quot;,
&quot;802722849528872960&quot;,
&quot;804450969630199808&quot;,
&quot;802722824094613504&quot;,
&quot;802730883328430080&quot;,
&quot;804161460388421632&quot;,
&quot;804161557037813760&quot;,
&quot;804176025549508608&quot;,
&quot;804213909950484480&quot;,
&quot;802716781096914944&quot;,
&quot;804168702743470080&quot;,
&quot;804170867323101184&quot;,
&quot;804214230017609728&quot;,
&quot;802329894783995904&quot;,
&quot;804176524424220672&quot;,
&quot;804168652218884096&quot;,
&quot;802716786692116480&quot;,
&quot;796587326209138688&quot;,
&quot;804161462930214912&quot;,
&quot;802693110097694720&quot;,
&quot;804161529510596608&quot;,
&quot;802722863324254208&quot;,
&quot;804214151575736320&quot;,
&quot;804175957157187584&quot;,
&quot;804170866358456320&quot;,
&quot;804170906959273984&quot;,
&quot;804476527994916864&quot;,
&quot;802693110378713088&quot;,
&quot;804176103894867968&quot;,
&quot;804176585098977280&quot;,
&quot;804170861765648384&quot;,
&quot;802731970781433856&quot;,
&quot;804161480407834624&quot;,
&quot;804168988644007936&quot;,
&quot;804125434563452928&quot;,
&quot;804168695030190080&quot;,
&quot;804176061767278592&quot;,
&quot;804214123675226112&quot;,
&quot;804168647143776256&quot;,
&quot;804170864584220672&quot;,
&quot;804125369941811200&quot;,
&quot;804117411426074624&quot;,
&quot;804214086887198720&quot;,
&quot;802685281873559552&quot;,
&quot;804475646389751808&quot;,
&quot;804161513224069120&quot;,
&quot;804213975557787648&quot;,
&quot;804170917117878272&quot;,
&quot;804161454579310592&quot;,
&quot;804176264767442944&quot;,
&quot;804170919051452416&quot;,
&quot;804484041062928384&quot;,
&quot;802722882722594816&quot;,
&quot;804175969425526784&quot;,
&quot;804214074832556032&quot;,
&quot;802731965378854912&quot;,
&quot;796566781212106752&quot;,
&quot;804170935082082304&quot;,
&quot;804449211747061760&quot;,
&quot;802716779519541248&quot;,
&quot;797153093287583744&quot;,
&quot;804175956737712128&quot;,
&quot;804168644597833728&quot;,
&quot;804161511915491328&quot;,
&quot;804125338950144000&quot;,
&quot;804169093656797184&quot;,
&quot;804125464724692992&quot;,
&quot;804175955865341952&quot;,
&quot;804170865326612480&quot;,
&quot;804512127879925760&quot;,
&quot;804176050090381312&quot;,
&quot;802685280397164544&quot;,
&quot;802731960735760384&quot;,
&quot;804175973573693440&quot;,
&quot;804168793944461312&quot;,
&quot;804512418926874624&quot;,
&quot;802731994282119168&quot;,
&quot;804161535156084736&quot;,
&quot;802716787161563136&quot;,
&quot;804161454273171456&quot;,
&quot;804170906003017728&quot;,
&quot;802722852175794176&quot;,
&quot;804176072232067072&quot;,
&quot;804176451963379712&quot;,
&quot;804175958809743360&quot;,
&quot;804170925376462848&quot;,
&quot;804125454725517312&quot;,
&quot;804170874734436352&quot;,
&quot;804214095770734592&quot;,
&quot;804170946255753216&quot;,
&quot;804125452120809472&quot;,
&quot;804117221957095424&quot;,
&quot;804171800434151424&quot;,
&quot;802693123330408448&quot;,
&quot;804171805626654720&quot;,
&quot;804170914387386368&quot;,
&quot;804214084240592896&quot;,
&quot;804171805827981312&quot;,
&quot;804125303768322048&quot;,
&quot;804170907152257024&quot;,
&quot;802716787794903040&quot;,
&quot;804161524582289408&quot;,
&quot;804170901129191424&quot;,
&quot;804168936802455552&quot;,
&quot;804176059225530368&quot;,
&quot;804176573644333056&quot;,
&quot;804161483054485504&quot;,
&quot;802731955425771520&quot;,
&quot;802722824153649152&quot;,
&quot;804171803420450816&quot;,
&quot;804169094873145344&quot;,
&quot;804214110089875456&quot;,
&quot;804168941143515136&quot;,
&quot;804176348913569792&quot;,
&quot;804170910771941376&quot;,
&quot;802678350052196352&quot;,
&quot;804169502991552512&quot;,
&quot;804176030792388608&quot;,
&quot;802731968080302080&quot;,
&quot;804503255131590656&quot;,
&quot;802644704193073152&quot;,
&quot;804221219066269696&quot;,
&quot;804168624679129088&quot;,
&quot;804176700912099328&quot;,
&quot;802722871268265984&quot;,
&quot;804168639627583488&quot;,
&quot;804161530773082112&quot;,
&quot;804220431828750336&quot;,
&quot;804125419434598400&quot;,
&quot;802678352665563136&quot;,
&quot;804170909626851328&quot;,
&quot;804161479111794688&quot;,
&quot;804254094612205568&quot;,
&quot;804214044742619136&quot;,
&quot;804213956473704448&quot;,
&quot;804214055505416192&quot;,
&quot;804176029420806144&quot;,
&quot;802730885966647296&quot;,
&quot;804125331329048576&quot;,
&quot;802722826246606848&quot;,
&quot;803420315891191808&quot;,
&quot;804176079748304896&quot;,
&quot;802693113499275264&quot;,
&quot;804170950798184448&quot;,
&quot;802722837306986496&quot;,
&quot;804161491707334656&quot;,
&quot;804175983786778624&quot;,
&quot;804170892786765824&quot;,
&quot;802731980650631168&quot;,
&quot;804171799788183552&quot;,
&quot;804449868948148224&quot;,
&quot;804213903021494272&quot;,
&quot;802693116250738688&quot;,
&quot;804213964954374144&quot;,
&quot;802731953936793600&quot;,
&quot;804176034948898816&quot;,
&quot;804176023943090176&quot;,
&quot;802722848187011072&quot;,
&quot;804214076061700096&quot;,
&quot;802685262835613696&quot;,
&quot;804168656513851392&quot;,
&quot;804213923665645568&quot;,
&quot;804176045879255040&quot;,
&quot;804170921496776704&quot;,
&quot;804175964404944896&quot;,
&quot;804214208769478656&quot;,
&quot;804168665170939904&quot;,
&quot;804170895701762048&quot;,
&quot;802731948664868864&quot;,
&quot;804120113891954688&quot;,
&quot;802335946204172288&quot;,
&quot;804170881566957568&quot;,
&quot;802666242585841664&quot;,
&quot;804170893759844352&quot;,
&quot;804125389243998208&quot;,
&quot;804125351486873600&quot;,
&quot;804170921530286080&quot;,
&quot;804170885450883072&quot;,
&quot;804168985938726912&quot;,
&quot;804161500506939392&quot;,
&quot;802731941710712832&quot;,
&quot;804214015202136064&quot;,
&quot;802656049046880256&quot;,
&quot;804208821320208384&quot;,
&quot;804125328787300352&quot;,
&quot;804214090775105536&quot;,
&quot;797224149600051200&quot;,
&quot;804161499311607808&quot;,
&quot;804170912697126912&quot;,
&quot;804170938785697792&quot;,
&quot;804125333967310848&quot;,
&quot;802716786377543680&quot;,
&quot;804213947535429632&quot;,
&quot;804109877805973504&quot;,
&quot;804214136296099840&quot;,
&quot;804170957966204928&quot;,
&quot;804161490482597888&quot;,
&quot;804161501844967424&quot;,
&quot;804175987918168064&quot;,
&quot;804161521960849408&quot;,
&quot;802680979038064640&quot;,
&quot;804169097242972160&quot;,
&quot;804175986605395968&quot;,
&quot;804168708351254528&quot;,
&quot;788940164851548160&quot;,
&quot;801630577777389568&quot;,
&quot;804214030054166528&quot;,
&quot;804170916362948608&quot;,
&quot;804176000522096640&quot;,
&quot;804213933321146368&quot;,
&quot;804168992402104320&quot;,
&quot;802656057401933824&quot;,
&quot;804214152905543680&quot;,
&quot;804102352499298304&quot;,
&quot;804172054051086336&quot;,
&quot;804480654309036032&quot;,
&quot;802716791339405312&quot;,
&quot;804214220119265280&quot;,
&quot;804170958029119488&quot;,
&quot;802693111099817984&quot;,
&quot;804170914219614208&quot;,
&quot;804170911703031808&quot;,
&quot;804214198124122112&quot;,
&quot;804176021103501312&quot;,
&quot;804214181242048512&quot;,
&quot;804125258515976192&quot;,
&quot;804170941671378944&quot;,
&quot;804214021896245248&quot;,
&quot;804125439533703168&quot;,
&quot;804214073217961984&quot;,
&quot;750842193132093440&quot;,
&quot;802722882647412736&quot;,
&quot;804170890878312448&quot;,
&quot;804168627057254400&quot;,
&quot;804170931034624000&quot;,
&quot;804213941680394240&quot;,
&quot;804207853941739520&quot;,
&quot;804214071993012224&quot;,
&quot;802693115021807616&quot;,
&quot;804168792111505408&quot;,
&quot;784278849155710976&quot;,
&quot;804214096655732736&quot;,
&quot;804214150040834048&quot;,
&quot;804170870422691840&quot;,
&quot;804214236665794560&quot;,
&quot;803420991047991296&quot;,
&quot;804214012400553984&quot;,
&quot;804176521744060416&quot;,
&quot;804213997250727936&quot;,
&quot;804214108357840896&quot;,
&quot;804170908834127872&quot;,
&quot;804125318779691008&quot;,
&quot;804213982100688896&quot;,
&quot;802722868583596032&quot;,
&quot;804176051252158464&quot;,
&quot;804168711018876928&quot;,
&quot;804176697527296000&quot;,
&quot;802680972142628864&quot;,
&quot;802722864746123264&quot;,
&quot;802666243055603712&quot;,
&quot;804214069275103232&quot;,
&quot;804102149641785344&quot;,
&quot;804170905050910720&quot;,
&quot;804481787090096128&quot;,
&quot;802722883460792320&quot;,
&quot;804125266002808832&quot;,
&quot;804168793176903680&quot;,
&quot;804109882013175808&quot;,
&quot;802731996895170560&quot;,
&quot;804161532295614464&quot;,
&quot;802722834672963584&quot;,
&quot;804102199428173824&quot;,
&quot;802383132744929280&quot;,
&quot;804175997594472448&quot;,
&quot;804125409431183360&quot;,
&quot;802685279054987264&quot;,
&quot;804170878542909440&quot;,
&quot;804175992137637888&quot;,
&quot;804169094235611136&quot;,
&quot;804161506831994880&quot;,
&quot;804171800421523456&quot;,
&quot;802716780693946368&quot;,
&quot;804109874047877120&quot;,
&quot;804170876093390848&quot;,
&quot;802680981856321536&quot;,
&quot;804170948969467904&quot;,
&quot;804170894737117184&quot;,
&quot;804214156902502400&quot;,
&quot;804214052871180288&quot;,
&quot;804125391739609088&quot;,
&quot;804170902089687040&quot;,
&quot;804125298730962944&quot;,
&quot;804161562217779200&quot;,
&quot;802716790773174272&quot;,
&quot;804480830046392320&quot;,
&quot;804098915791458304&quot;,
&quot;804214160853749760&quot;,
&quot;804213948865024000&quot;,
&quot;804117436570927104&quot;,
&quot;804214170530009088&quot;,
&quot;802685264861777920&quot;,
&quot;804213986291011584&quot;,
&quot;804125457153974272&quot;,
&quot;804125437101051904&quot;,
&quot;804168791604039680&quot;,
&quot;799795973026197504&quot;,
&quot;802730883382640640&quot;,
&quot;804214171654082561&quot;,
&quot;804497103597572096&quot;,
&quot;804125296092700672&quot;,
&quot;804176607878287360&quot;,
&quot;804213974223785984&quot;,
&quot;804161520614432768&quot;,
&quot;804176511530930176&quot;,
&quot;804214196719243264&quot;,
&quot;802722856516898816&quot;,
&quot;804170957521608704&quot;,
&quot;804125429454790656&quot;,
&quot;804169114338910208&quot;,
&quot;802722840125558784&quot;,
&quot;804170925204541440&quot;,
&quot;804125404427423744&quot;,
&quot;804175985238007808&quot;,
&quot;804214226649583616&quot;,
&quot;804213957543251968&quot;,
&quot;804170952714981376&quot;,
&quot;804170903251509248&quot;,
&quot;804449941681573888&quot;,
&quot;804176602685739008&quot;,
&quot;804201225770995712&quot;,
&quot;804170927259750400&quot;,
&quot;804170932955615232&quot;,
&quot;804161516952850432&quot;,
&quot;804176408862756864&quot;,
&quot;802604399804731392&quot;,
&quot;804176052531421184&quot;,
&quot;804170897626947584&quot;,
&quot;802722862006927360&quot;,
&quot;804176563762552832&quot;,
&quot;804168637111001088&quot;,
&quot;804214172996046848&quot;,
&quot;804176053852626944&quot;,
&quot;804170905222877184&quot;,
&quot;804169100770336768&quot;,
&quot;804170876726775808&quot;,
&quot;804170908645384192&quot;,
&quot;804176860505366528&quot;,
&quot;804168971342503936&quot;,
&quot;804214189567741952&quot;,
&quot;804170915184304128&quot;
    };

// 获取当前线程编号（1-based）
int threadNum = ctx.getThreadNum();

// 转换为0-based索引
int index = threadNum;

// 检查索引是否越界
String issueThreadCodezoneId = &quot;&quot;;
if (index &lt; codezone_ids.length) {
    issueThreadCodezoneId = codezone_ids[index];
} else {
    log.error(&quot;ERROR: 线程数过大&quot;);
    JMeterContextService.getContext().getThread().stop();
}

// 将业务ID存入变量
vars.put(&quot;issueThreadCodezoneId&quot;, issueThreadCodezoneId);
log.info(&quot; 注入变量: issueThreadCodezoneId: &quot; + issueThreadCodezoneId);
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="mock fork codezone interface" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.apache.jmeter.threads.JMeterContextService;

// 定义你的业务ID列表（数组）
String[] codezone_ids = {
&quot;804512418926874624&quot;
    };

// 获取当前线程编号（1-based）
int threadNum = ctx.getThreadNum();

// 转换为0-based索引
int index = threadNum;

// 检查索引是否越界
String issueThreadCodezoneId = &quot;&quot;;
if (index &lt; codezone_ids.length) {
    issueThreadCodezoneId = codezone_ids[index];
} else {
    log.error(&quot;ERROR: 线程数过大&quot;);
    JMeterContextService.getContext().getThread().stop();
}

// 将业务ID存入变量
vars.put(&quot;issueThreadCodezoneId&quot;, issueThreadCodezoneId);
log.info(&quot; 注入变量: issueThreadCodezoneId: &quot; + issueThreadCodezoneId);
</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas checkout branch">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/${issueThreadCodezoneId}/git/createAndCheckBranch</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;remoteName&quot;: &quot;origin&quot;,&#xd;
  &quot;newBranch&quot;: &quot;${issueThreadBranch}&quot;,&#xd;
  &quot;remoteBranch&quot;: &quot;main&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas 创建playground">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/${issueThreadCodezoneId}/playground</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();
bsh.shared.util.info(&quot;原始响应数据: &quot; + jsonResult);

// 创建 JSONObject 解析响应
JSONObject jsonObject = new JSONObject(jsonResult);

// 检查 status
String status = jsonObject.getString(&quot;status&quot;);
bsh.shared.util.info(&quot;status: &quot; + status);

// 如果响应成功 ( status=&quot;success&quot;)
if ( &quot;success&quot;.equals(status)) {
    // 提取 data 对象中的 id
    JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
    String issueThreadPlaygroundId = data.getString(&quot;id&quot;);
    
    bsh.shared.util.info(&quot;解析到的 issueThreadPlaygroundId: &quot; + issueThreadPlaygroundId);
    // 将 id 存入 JMeter 变量中
    vars.put(&quot;issueThreadPlaygroundId&quot;, issueThreadPlaygroundId);
} else {
    bsh.shared.util.error(&quot;响应未成功，无法提取 issueThreadPlaygroundId&quot;);
    prev.setStopTest(true);
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [PaaS] 获取中间件配置列表">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/${issueThreadCodezoneId}/middlewareDefines/config</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [PaaS] 获取playground绑定信息 ">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/playgrounds/${issueThreadPlaygroundId}/bindInfo</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend update issueThread playground">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
    &quot;playground_id&quot;: &quot;${issueThreadPlaygroundId}&quot;,&#xd;
    &quot;code_status&quot;:&quot;INITIALIZED&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas 获取ticket" enabled="true">
          <stringProp name="TestPlan.comments">${ticket_1}</stringProp>
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/sdk/ticket</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;playgroundId&quot;:&quot;${issueThreadPlaygroundId}&quot;,&quot;tillTime&quot;:0,&quot;userInfo&quot;:{&quot;name&quot;:&quot;stress_tester&quot;,&quot;userId&quot;:&quot;stress_tester&quot;,&quot;temporaryUser&quot;:false}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor guiclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.gui.JSONPathExtractorGui" testclass="com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor" testname="-&gt; ticket" enabled="true">
            <stringProp name="TestPlan.comments">${ticket_1}</stringProp>
            <stringProp name="VAR">ticket</stringProp>
            <stringProp name="JSONPATH">$..ticket</stringProp>
            <stringProp name="DEFAULT"></stringProp>
            <stringProp name="VARIABLE"></stringProp>
            <stringProp name="SUBJECT">BODY</stringProp>
            <stringProp name="INPUT_FORMAT">JSON</stringProp>
          </com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas 获取 js ticket" enabled="true">
          <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/api/v1/jssdk/ticket</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;ticket&quot;:&quot;${ticket_1}&quot;,&quot;packageVersion&quot;:&quot;0.9.212&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

try {
    // 获取并解析JSON响应
    JSONObject json = new JSONObject(prev.getResponseDataAsString());
    JSONObject data = json.getJSONObject(&quot;data&quot;);
    
    // 存储userId
    vars.put(&quot;userId&quot;, data.getString(&quot;userId&quot;));
    
    // 提取url中的路径和查询参数部分
    String url = data.getString(&quot;url&quot;);
    String pathWithQuery = url.substring(url.indexOf(&quot;/&quot;, url.indexOf(&quot;//&quot;) + 2));
    
    vars.put(&quot;path&quot;, pathWithQuery);

    bsh.shared.util.info(&quot;path :&quot;+ pathWithQuery);
} catch (Exception e) {
    prev.setStopTest(true);
    bsh.shared.util.error(&quot;Error processing response: &quot; + e.getMessage());
    SampleResult.setSuccessful(false);
    SampleResult.setResponseMessage(&quot;Script error: &quot; + e.toString());

}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="-&gt; *  IDEServer 事件接口" enabled="true"/>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Cache-Control</stringProp>
                <stringProp name="Header.value">no-cache</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Pragma</stringProp>
                <stringProp name="Header.value">no-cache</stringProp>
              </elementProp>
              <elementProp name="User-Agent" elementType="Header">
                <stringProp name="Header.name">User-Agent</stringProp>
                <stringProp name="Header.value">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0</stringProp>
              </elementProp>
              <elementProp name="Origin" elementType="Header">
                <stringProp name="Header.name">Origin</stringProp>
                <stringProp name="Header.value">${wssOrigin}</stringProp>
              </elementProp>
              <elementProp name="Accept-Encoding" elementType="Header">
                <stringProp name="Header.name">Accept-Encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate, br, zstd</stringProp>
              </elementProp>
              <elementProp name="Accept-Language" elementType="Header">
                <stringProp name="Header.name">Accept-Language</stringProp>
                <stringProp name="Header.value">zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</stringProp>
              </elementProp>
              <elementProp name="Sec-WebSocket-Extensions" elementType="Header">
                <stringProp name="Header.name">Sec-WebSocket-Extensions</stringProp>
                <stringProp name="Header.value">permessage-deflate; client_max_window_bits</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Upgrade</stringProp>
                <stringProp name="Header.value">websocket</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">Upgrade</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * paas wss connect ide" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${PAAS_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="readTimeout">60000</stringProp>
          </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler" testname="-&gt; * paas wss auth">
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${PAAS_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">40{&quot;paasDomain&quot;:&quot;https://${PAAS_DOMAIN}&quot;,&quot;ticket&quot;:&quot;${ticket_1}&quot;,&quot;themeType&quot;:&quot;dark&quot;,&quot;i18nLanguage&quot;:&quot;EN&quot;,&quot;defaultLspLang&quot;:[&quot;html&quot;,&quot;css&quot;,&quot;less&quot;,&quot;sass&quot;],&quot;openLspDiagnostic&quot;:false,&quot;showModifyIcon&quot;:true,&quot;focusEditorPosition&quot;:&quot;TOP&quot;,&quot;isSplitCode&quot;:true,&quot;isInsertCrdt&quot;:true,&quot;isLegacyMarkdownMath&quot;:false,&quot;userInfo&quot;:{&quot;userId&quot;:&quot;user_2lxwpMj4OvyUlM6Eanz5eC200v9&quot;,&quot;username&quot;:&quot;xiaoyougithub&quot;,&quot;avatarUrl&quot;:&quot;https://img.clerk.com/eyJ0eXBlIjoicHJveHkiLCJzcmMiOiJodHRwczovL2ltYWdlcy5jbGVyay5kZXYvb2F1dGhfZ2l0aHViL2ltZ18ybHh3cElaNmtZMmVhb3Rqd1FSZjFPcjNUcUoifQ&quot;},&quot;xtermStyle&quot;:{},&quot;enableSentry&quot;:false,&quot;isOpenDebugMode&quot;:false,&quot;defaultOpenFiles&quot;:[&quot;README.md&quot;,&quot;CHANGELOG.md&quot;],&quot;specialFileHighlight&quot;:[{&quot;fileName&quot;:&quot;paas_test&quot;,&quot;languageType&quot;:&quot;typescript&quot;}],&quot;recordBrowser&quot;:false,&quot;persistenceWebData&quot;:false,&quot;customFileTreeAction&quot;:false,&quot;contextMenu&quot;:[[{&quot;text&quot;:{&quot;ZH&quot;:&quot;剪切&quot;,&quot;EN&quot;:&quot;Cut&quot;},&quot;shortcutKey&quot;:&quot;Ctrl/Cmd+X&quot;,&quot;actionName&quot;:&quot;cut&quot;,&quot;className&quot;:&quot;contextmenu-cut&quot;,&quot;shortcutClassName&quot;:&quot;&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;复制&quot;,&quot;EN&quot;:&quot;Copy&quot;},&quot;shortcutKey&quot;:&quot;Ctrl/Cmd+C&quot;,&quot;actionName&quot;:&quot;copy&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;粘贴&quot;,&quot;EN&quot;:&quot;Paste&quot;},&quot;shortcutKey&quot;:&quot;Ctrl/Cmd+V&quot;,&quot;actionName&quot;:&quot;paste&quot;}],[{&quot;text&quot;:{&quot;ZH&quot;:&quot;撤销&quot;,&quot;EN&quot;:&quot;Undo&quot;},&quot;shortcutKey&quot;:&quot;Ctrl/Cmd+Z&quot;,&quot;actionName&quot;:&quot;undo&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;注释代码&quot;,&quot;EN&quot;:&quot;Toggle Line Comment&quot;},&quot;shortcutKey&quot;:&quot;Cmd/Ctrl+/&quot;,&quot;actionShortcutKey&quot;:&quot;Mod-/&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;全选&quot;,&quot;EN&quot;:&quot;Select All&quot;},&quot;shortcutKey&quot;:&quot;Ctrl/Cmd+A&quot;,&quot;actionName&quot;:&quot;selectAll&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;选中整行&quot;,&quot;EN&quot;:&quot;Select Line&quot;},&quot;shortcutKey&quot;:&quot;Ctrl+L&quot;,&quot;actionName&quot;:&quot;selectLine&quot;},{&quot;text&quot;:{&quot;ZH&quot;:&quot;格式化代码&quot;,&quot;EN&quot;:&quot;Format Document&quot;},&quot;shortcutKey&quot;:&quot;Cmd/Ctrl+Alt+F&quot;,&quot;actionShortcutKey&quot;:&quot;Mod-Alt-f&quot;}]],&quot;agentUserId&quot;:&quot;4313dfe8-4c7c-4be4-bd5c-7b33b82743c9&quot;}</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; 循环读取数据，获取 syncPlayground">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">5</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; wss read msg">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">30000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="false">
                <stringProp name="JSONPostProcessor.referenceNames">status,dockerId</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">$.[1].status,$.[1].dockerId</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">NOT_FOUND</stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.*;

String message = prev.getResponseDataAsString();
String dockerId = &quot;&quot;; // 初始化 dockerId

bsh.shared.util.info(&quot;原始 WSS 消息: &quot; + message);

try {
    if (message.contains(&quot;syncPlaygroundInfo&quot;)) {
        JSONArray jsonArray = new JSONArray(message.substring(2));
        String eventType = jsonArray.getString(0);

        if (eventType.equals(&quot;syncPlaygroundInfo&quot;)) {
            JSONObject data = jsonArray.getJSONObject(1);
            dockerId = data.getString(&quot;dockerId&quot;); // 获取 dockerId
            bsh.shared.util.info(&quot;dockerId: &quot; + dockerId);
            vars.put(&quot;dockerId&quot;, dockerId); // 将 dockerId 存储到 JMeter 变量中
        } else {
            log.warn(&quot;接收到的不是 syncPlaygroundInfo 事件&quot;);
        }
    } else {
        bsh.shared.util.info(&quot;消息中不包含 syncPlaygroundInfo&quot;);
    }
} catch (JSONException e) {
    bsh.shared.util.error(&quot;JSON 解析错误: &quot; + e.getMessage(), e);
}

// 可以在这里添加其他逻辑，例如根据 dockerId 的值执行不同的操作</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="false">
              <stringProp name="IfController.condition">&quot;${status}&quot; == &quot;INACTIVE&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler" testname="-&gt; * paas wss active">
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">42[&quot;active&quot;,{},{&quot;currentDockerId&quot;:&quot;${dockerId}&quot;}]</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler>
          <hashTree>
            <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="-&gt; 验证 dockerId ">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">// BeanShell Sampler
String dockerId = vars.get(&quot;dockerId&quot;);
bsh.shared.util.info(&quot;dockerId 的值: &quot; + dockerId);</stringProp>
            </BeanShellPreProcessor>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="-&gt; 解析并打印返回值">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.*;

String message = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;原始 WSS 消息: &quot; + message);

try {
    JSONArray jsonArray = new JSONArray(message.substring(2));
    String eventType = jsonArray.getString(0);
    JSONObject data = jsonArray.getJSONObject(1);

    bsh.shared.util.info(&quot;事件类型: &quot; + eventType);

    JSONArray names = data.names(); // 获取键名数组
    for (int i = 0; i &lt; names.length(); i++) {
        String key = names.getString(i);
        String value = data.get(key).toString();

        bsh.shared.util.info(key + &quot;: &quot; + value);
        vars.put(key, value);
    }

    boolean success = data.getBoolean(&quot;success&quot;);
    String reason = data.getString(&quot;reason&quot;);
    bsh.shared.util.info(&quot;success: &quot; + success);
    bsh.shared.util.info(&quot;reason: &quot; + reason);

    if (data.has(&quot;error&quot;)) {
        String error = data.getString(&quot;error&quot;);
        bsh.shared.util.info(&quot;error: &quot; + error);
        vars.put(&quot;error&quot;, error);
    }

    vars.put(&quot;eventType&quot;, eventType);

} catch (JSONException e) {
    bsh.shared.util.error(&quot;JSON 解析错误: &quot; + e.getMessage(), e); // 打印完整的错误信息，包括堆栈跟踪
}</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler" testname="-&gt; * paas wss restart">
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">42[&quot;restartServer&quot;,{},{&quot;currentDockerId&quot;:&quot;${dockerId}&quot;}]</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.RequestResponseWebSocketSampler>
          <hashTree>
            <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="-&gt; 验证 dockerId ">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">// BeanShell Sampler
String dockerId = vars.get(&quot;dockerId&quot;);
bsh.shared.util.info(&quot;dockerId 的值: &quot; + dockerId);</stringProp>
            </BeanShellPreProcessor>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="-&gt; 解析并打印返回值" enabled="false">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.*;

String message = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;原始 WSS 消息: &quot; + message);

try {
    JSONArray jsonArray = new JSONArray(message.substring(2));
    String eventType = jsonArray.getString(0);
    JSONObject data = jsonArray.getJSONObject(1);

    bsh.shared.util.info(&quot;事件类型: &quot; + eventType);

    JSONArray names = data.names(); // 获取键名数组
    for (int i = 0; i &lt; names.length(); i++) {
        String key = names.getString(i);
        String value = data.get(key).toString();

        bsh.shared.util.info(key + &quot;: &quot; + value);
        vars.put(key, value);
    }

    boolean success = data.getBoolean(&quot;success&quot;);
    String reason = data.getString(&quot;reason&quot;);
    bsh.shared.util.info(&quot;success: &quot; + success);
    bsh.shared.util.info(&quot;reason: &quot; + reason);

    if (data.has(&quot;error&quot;)) {
        String error = data.getString(&quot;error&quot;);
        bsh.shared.util.info(&quot;error: &quot; + error);
        vars.put(&quot;error&quot;, error);
    }

    vars.put(&quot;eventType&quot;, eventType);

} catch (JSONException e) {
    bsh.shared.util.error(&quot;JSON 解析错误: &quot; + e.getMessage(), e); // 打印完整的错误信息，包括堆栈跟踪
}</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="-&gt; * paas wss 关闭连接">
            <stringProp name="statusCode">1000</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
          </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增]  [Backend] 邀请成员 /invite/link/create" enabled="true">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/invite/link/create</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
    &quot;period&quot;: 1,&#xd;
    &quot;source&quot;: 3,&#xd;
    &quot;workspace_id&quot;: &quot;${workspaceId}&quot;,&#xd;
    &quot;project_id&quot;: &quot;${projectId}&quot;,&#xd;
    &quot;thread_id&quot;: &quot;${issueThreadId}&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [Backend]  获取别名列表 /thread/urlAlias/list" enabled="true">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/urlAlias/list</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="连接 issueThread 制定需求" enabled="true"/>
        <hashTree>
          <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="[AI] 连接 issueThread" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="readTimeout">60000</stringProp>
          </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] isRoot" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">40{&quot;playgroundId&quot;:&quot;${issueThreadPlaygroundId}&quot;,&quot;isRoot&quot;:false,&quot;projectId&quot;:&quot;${projectId}&quot;,&quot;token&quot;:&quot;${token}&quot;}</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] uMakePlan（implement bubble sort）" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">60000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">420[&quot;uMakePlan&quot;,&quot;在Go项目中实现冒泡排序算法&quot;,&quot;用户要求实现冒泡排序算法。当前项目是一个Go语言项目，包含基础的main.go文件。需要：\n\n1. 实现冒泡排序函数 bubbleSort\n2. 在main函数中添加测试示例\n3. 展示排序前后的数组状态\n4. 确保代码结构清晰，包含必要的注释\n\n冒泡排序是一种简单的排序算法，通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换。\n\n实现要求：\n- 使用Go语言语法\n- 函数接收int切片作为参数\n- 原地排序（修改原数组）\n- 添加适当的测试用例展示功能&quot;,[&quot;在main.go文件中实现`bubbleSort`函数，使其接收一个int切片并进行冒泡排序。&quot;,&quot;在`main`函数中，创建一个int类型的切片用于测试。&quot;,&quot;在排序前打印测试切片的状态。&quot;,&quot;调用`bubbleSort`函数对测试切片进行排序。&quot;,&quot;在排序后打印测试切片的状态。&quot;,&quot;添加必要的注释解释代码功能。&quot;]]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 1" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor uMakePlan（implement bubble sort）(500 steps)" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(    parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;planId&quot;) == null ,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="uMakePlanLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">uMakePlanLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor uMakePlan（implement bubble sort）" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    log.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize uMakePlan response( taskPlanned)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;
import org.json.JSONObject;

try {
    // 获取原始响应字符串
    responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
       
    }else{
// 提取状态码和JSON部分（假设格式为 &quot;42[\&quot;planUpdated\&quot;, {...}]&quot;）
    statusCode = responseData.substring(0, responseData.indexOf(&quot;[&quot;));
    jsonStr = responseData.substring(responseData.indexOf(&quot;[&quot;));
    
    bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

    // 仅当状态码为42且包含planUpdated时才处理
    if (statusCode.equals(&quot;42&quot;)) {
        try {
            // 解析JSON数组
            jsonArray = new JSONArray(jsonStr);
            
            // 检查第一个元素是否是&quot;planUpdated&quot;
            if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskPlanned&quot;.equals(jsonArray.getString(0))) {
                bsh.shared.util.info(&quot;✅ 检测到planUpdated消息&quot;);
                
                if (jsonArray.length() &gt; 1) {
                    // 获取任务数据对象
                    taskData = jsonArray.getJSONObject(1);

                    if (taskData.has(&quot;id&quot;)) {
				    // 存在 id 字段
				    vars.put(&quot;planId&quot;, &quot;1&quot;);
				} else {
				    // 不存在 id 字段
				    log.warn(&quot;⚠️ JSON 不包含 id 字段&quot;);
				}
                    
	           }
            } else {
                log.warn(&quot;⏩ 消息类型不是planUpdated&quot;);
            }
        } catch (Exception e) {
            bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
        }
    } else {
        log.warn(&quot;⏩ 状态码不是42&quot;);
    }

    	
    }
    
    
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss execute issuePlan_uStartTask" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;uStartTask&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 2" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor issuePlan_uStartTask" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(   parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; (  vars.get(&quot;taskStatus&quot;) == null  || vars.get(&quot;taskStatus&quot;) !=&quot;done&quot;),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="issuePlan_uStartTaskLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">101</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">issuePlan_uStartTaskLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor issuePlan_uStartTask" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    bsh.shared.util.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    bsh.shared.util.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize issuePlan_uStartTask response (taskStateUpdated done)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskStateUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 taskStateUpdated 消息&quot;);

                    // 第二个元素是任务状态
                    if (jsonArray.length() &gt; 1) {
                        String taskStatus = jsonArray.getString(1);
                        bsh.shared.util.info(&quot;🛠️ 任务状态: &quot; + taskStatus);

                        // 设置变量供后续使用
                        vars.put(&quot;taskStatus&quot;, taskStatus);
                    }
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] 发消息追加需求（实现二分排序）" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">420[&quot;message&quot;,&quot;实现二分排序&quot;,false,false]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 3" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听新需求消息处理情况" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(     parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;addTaskStepConfirmation&quot;) == null,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">requirementMessageLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听新需求消息处理" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    bsh.shared.util.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    bsh.shared.util.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="monitor message response (addTaskStepConfirmation)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;addTaskStepConfirmation&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 addTaskStepConfirmation 消息&quot;);

                  
                   // 设置变量供后续使用
                   vars.put(&quot;addTaskStepConfirmation&quot;, &quot;true&quot;);
                   bsh.shared.util.info(&quot;✅✅ ✅ ✅ ✅  检测到 addTaskStepConfirmation 消息&quot;);
                    
                } else {
                    log.warn(&quot;⏩ 消息类型不是 addTaskStepConfirmation&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss uAddStep" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;uAddStep&quot;,{&quot;title&quot;:&quot;实现二分插入排序算法和测试用例&quot;,&quot;task_actions&quot;:[{&quot;action&quot;:&quot;modify_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;main.go&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;在现有bubbleSort函数后添加binarySearch辅助函数，使用二分查找算法在已排序的数组切片中找到目标值的正确插入位置，接收参数为已排序的切片、目标值和搜索范围的起始和结束索引，返回插入位置的索引\n添加binaryInsertionSort函数，实现二分插入排序算法，接收[]int类型参数并进行原地排序，使用外层循环遍历数组元素，内层调用binarySearch找到插入位置，然后将元素向右移动并插入到正确位置\n修改main函数，在现有测试用例后添加二分插入排序的测试用例，包括随机顺序、已排序、逆序、包含重复元素、单个元素和空数组的测试\n为每个测试用例添加标题和排序前后的数组打印输出\n添加详细的中文注释解释二分插入排序算法的工作原理，包括如何使用二分查找优化插入排序的时间复杂度&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;0&quot;}],&quot;merged&quot;:&quot;inited&quot;}]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 4" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor uAddStep" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(    parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;addTaskStepStatus&quot;) == null,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="uAddStepLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">uAddStepLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor uAddStep" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    bsh.shared.util.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize uAddStep response( 431)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;431&quot;.equals(statusCode)) {
           
                  
                        // 设置变量供后续使用
                        vars.put(&quot;addTaskStepStatus&quot;, &quot;true&quot;);
                    
              
        } else {
            log.warn(&quot;⏩ 状态码不是431&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss execute uStartTask" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">422[&quot;uStartTask&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 5" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor uStartTask" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; ( vars.get(&quot;taskStatus&quot;) == null  || vars.get(&quot;taskStatus&quot;) !=&quot;done&quot;),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="uStartTaskLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">101</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">uStartTaskLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor uStartTask" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    bsh.shared.util.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response " enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize uStartTask response( taskStateUpdated done)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskStateUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 taskStateUpdated 消息&quot;);

                    // 第二个元素是任务状态
                    if (jsonArray.length() &gt; 1) {
                        String taskStatus = jsonArray.getString(1);
                        bsh.shared.util.info(&quot;🛠️ 任务状态: &quot; + taskStatus);

                        // 设置变量供后续使用
                        vars.put(&quot;taskStatus&quot;, taskStatus);
                    }
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="[AI] 发消息追加需求（实现二分查找，更新日志）" enabled="false">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">422[&quot;message&quot;,&quot;实现现二分查找，方法需要抽取到单独的go文件中；另外在readme文件中更新下日志&quot;,false,false]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 6" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听新需求消息处理情况" enabled="false">
            <stringProp name="WhileController.condition">${__javaScript(     parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;addTaskStepConfirmation&quot;) == null,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">requirementMessageLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听新需求消息处理" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    log.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="monitor message response (addTaskStepConfirmation)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;addTaskStepConfirmation&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 addTaskStepConfirmation 消息&quot;);

                  
                   // 设置变量供后续使用
                   vars.put(&quot;addTaskStepConfirmation&quot;, &quot;true&quot;);
                   bsh.shared.util.info(&quot;✅✅ ✅ ✅ ✅  检测到 addTaskStepConfirmation 消息&quot;);
                    
                } else {
                    log.warn(&quot;⏩ 消息类型不是 addTaskStepConfirmation&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss uAddStep" enabled="false">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">423[&quot;uAddStep&quot;,{&quot;title&quot;:&quot;实现二分查找算法并抽取到单独文件，添加测试用例，更新README文档&quot;,&quot;task_actions&quot;:[{&quot;action&quot;:&quot;add_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;binary_search.go&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;创建新的Go文件实现二分查找算法，包含以下功能：\n- 添加package main声明\n- 实现BinarySearch函数（迭代版本），接收已排序的[]int切片、目标值和返回索引，找不到返回-1\n- 实现BinarySearchRecursive函数（递归版本），接收已排序的[]int切片、目标值、起始索引、结束索引参数，返回目标值索引，找不到返回-1\n- 为两个函数添加详细的中文注释，说明算法原理、参数说明、返回值说明、时间复杂度O(log n)和空间复杂度\n- 注释中解释二分查找的工作原理：通过不断将搜索区间对半分割来快速定位目标值&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;0&quot;},{&quot;action&quot;:&quot;modify_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;main.go&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;在现有排序算法测试后添加二分查找测试功能：\n- 在main函数末尾添加二分查找测试部分，使用分隔符标题\&quot;=== 二分查找测试 ===\&quot;\n- 创建已排序的测试数组用于二分查找测试\n- 测试BinarySearch迭代版本，包含存在的目标值、不存在的目标值、边界值（最小值、最大值）的测试用例\n- 测试BinarySearchRecursive递归版本，使用相同的测试用例\n- 为每个测试用例添加标题说明和结果输出\n- 测试边界情况：空数组、单元素数组、目标值小于最小值、目标值大于最大值的情况\n- 为每个测试结果添加清晰的输出格式，显示搜索目标、数组内容和查找结果&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;1&quot;},{&quot;action&quot;:&quot;modify_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;README.md&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;完全重写README文件内容，包含以下部分：\n- 添加项目标题和简介，说明这是一个Go语言算法实现项目\n- 添加功能列表部分，列出已实现的算法：冒泡排序、二分插入排序、二分查找（迭代和递归版本）\n- 添加文件结构说明，描述main.go和binary_search.go的作用\n- 添加使用说明部分，包含如何运行项目的命令\n- 添加开发日志部分，记录各算法的实现时间和版本信息：冒泡排序实现、二分插入排序实现、二分查找算法实现\n- 添加算法复杂度说明部分，列出各算法的时间和空间复杂度\n- 使用Markdown格式，包含适当的标题层级和代码块格式&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;2&quot;}],&quot;merged&quot;:&quot;inited&quot;}]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 7" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor uAddStep" enabled="false">
            <stringProp name="WhileController.condition">${__javaScript(    parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;addTaskStepStatus&quot;) == null,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="uAddStepLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">uAddStepLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor uAddStep" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    log.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize uAddStep response( 431)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;431&quot;.equals(statusCode)) {
           
                  
                        // 设置变量供后续使用
                        vars.put(&quot;addTaskStepStatus&quot;, &quot;true&quot;);
                    
              
        } else {
            log.warn(&quot;⏩ 状态码不是431&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss execute uStartTask" enabled="false">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">422[&quot;uStartTask&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="清零 pingCount 8" enabled="false">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));
log.info(&quot;====================清零 pingCount &quot;);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss monitor uStartTask" enabled="false">
            <stringProp name="WhileController.condition">${__javaScript(     parseInt(vars.get(&quot;pingCount&quot;)) &lt; parseInt(vars.get(&quot;pingCountMax&quot;)) &amp;&amp; vars.get(&quot;taskStatus&quot;) == null  || vars.get(&quot;taskStatus&quot;) !=&quot;done&quot;,)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="uStartTaskLoopCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">101</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">uStartTaskLoopCount</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss monitor uStartTask" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">false</stringProp>
                <stringProp name="RegexExtractor.refname">is_ping</stringProp>
                <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default">not_ping</stringProp>
                <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
                <stringProp name="RegexExtractor.match_number">1</stringProp>
              </RegexExtractor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">// 获取 isPing 变量（假设是字符串或数字）
String isPingStr = vars.get(&quot;is_ping&quot;); // 从 JMeter 变量中获取
log.info(&quot;isPingStr 的值: &quot; + isPingStr);
int isPing = 0;

try {
    isPing = Integer.parseInt(isPingStr); // 转换为整数
} catch (NumberFormatException e) {
    log.error(&quot;isPing 不是有效的数字: &quot; + isPingStr);
    isPing = 0; // 默认设为 0（非 2）
}

// 获取当前的 pingCount（如果没有则初始化为 0）
int pingCount = 0;
try {
    pingCount = Integer.parseInt(vars.get(&quot;pingCount&quot;));
} catch (Exception e) {
    log.warn(&quot;pingCount 不存在或非数字，初始化为 0&quot;);
}

// 判断 isPing 是否等于 2
if (isPing == 2) {
    pingCount++; // 如果是 2，pingCount +1
    log.info(&quot;isPing == 2，pingCount 更新为: &quot; + pingCount);
} else {
    pingCount = 0; // 如果不是 2，重置为 0
    log.info(&quot;isPing != 2，pingCount 重置为 0&quot;);
}

// 更新 pingCount 变量
vars.put(&quot;pingCount&quot;, String.valueOf(pingCount));</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response " enabled="true">
                <boolProp name="replyToPing">true</boolProp>
                <stringProp name="filterType">FilterPingOnly</stringProp>
              </eu.luminis.jmeter.wssampler.PingFrameFilter>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="anaylize uStartTask response( taskStateUpdated done)" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskStateUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 taskStateUpdated 消息&quot;);

                    // 第二个元素是任务状态
                    if (jsonArray.length() &gt; 1) {
                        String taskStatus = jsonArray.getString(1);
                        bsh.shared.util.info(&quot;🛠️ 任务状态: &quot; + taskStatus);

                        // 设置变量供后续使用
                        vars.put(&quot;taskStatus&quot;, taskStatus);
                    }
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
              <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">TextStomp</stringProp>
                <stringProp name="requestData">3</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 查看 commit 文件列表" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">423[&quot;uMakeCommitFileList&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; AI wss 监听查看 commit 文件列表" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">1</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听查看 commit 文件列表" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">6000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 获取 commit 信息" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">424[&quot;uMakeCommitMessage&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; AI wss 监听获取 commit 信息" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">1</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听获取 commit 信息" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">6000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="WebSocket Close" enabled="true">
            <stringProp name="statusCode">1000</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
          </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; backend git status" enabled="true">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/git-status</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[变更] [Backend] commit /thread/add-commit/async" enabled="true">
          <stringProp name="TestPlan.comments">要求容器激活，包括add</stringProp>
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/add-commit/async</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
    &quot;message&quot;: &quot;test commit&quot;,&#xd;
    &quot;file&quot;: &quot;.&quot;,&#xd;
    &quot;enable_co_author&quot;: &quot;false&quot;,&#xd;
    &quot;display_name&quot;: &quot;xiaoyougithub&quot;,&#xd;
    &quot;email&quot;: &quot;3220837922@qq.com&quot;,&#xd;
    &quot;account_email_id&quot;: &quot;&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP信息头管理器" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="提取cmd_id" enabled="true">
            <stringProp name="JSONPostProcessor.referenceNames">commit_cmd_id</stringProp>
            <stringProp name="JSONPostProcessor.jsonPathExprs">$.data.id</stringProp>
            <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
          </JSONPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; backend git check commit">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/git-check?cmd_id=${commit_cmd_id}</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析异步commit status" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;check commit 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

String checkCommitMsg = jsonObject.getString(&quot;msg&quot;);
bsh.shared.util.info(&quot;post process checkCommitMsg 的值: &quot; + checkCommitMsg);
bsh.shared.util.info(&quot;post process code 的值: &quot; + jsonObject.getInt(&quot;code&quot;));

// 如果 msg = Succeed，则获取 data 对象里面的 status 值添加到 vars 中
if(&quot;Succeed&quot;.equals(checkCommitMsg)){
	// 获取 data JSONObject
	JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
	// 获取 id 值 (threadId)
	int checkCommitStatus = data.getInt(&quot;status&quot;);
	String checkCommitStatusString = String.valueOf(checkCommitStatus);
	
	bsh.shared.util.info(&quot;post process checkCommitStatus 的值: &quot; + checkCommitStatusString);
	// 将 id 值设置为 JMeter 变量
	vars.put(&quot;checkCommitStatus&quot;, checkCommitStatusString);
}







</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname=" [Backend] /thread/push/async" enabled="true">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/push/async</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析 push_cmd_id" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;async push 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

// 获取 data JSONObject
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

// 获取 id 值 (cmd_id)
String push_cmd_id = data.getString(&quot;id&quot;);

bsh.shared.util.info(&quot;post process push_cmd_id 的值: &quot; + push_cmd_id);

// 将 id 值设置为 JMeter 变量
vars.put(&quot;push_cmd_id&quot;, push_cmd_id);</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[Backend] push /thread/git-check [复用接口]" enabled="true">
          <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.path">/thread/git-check?cmd_id=${push_cmd_id}</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Project-ID</stringProp>
                <stringProp name="Header.value">${projectId}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Thread-ID</stringProp>
                <stringProp name="Header.value">${issueThreadId}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="[剔除][AI] 监听需求制定并解析签名数据、任务规模、建议分支等" enabled="false">
          <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount&quot;)) &lt; 200 &amp;&amp; vars.get(&quot;monitorFlagSpecUpdated&quot;) == null),)}</stringProp>
        </WhileController>
        <hashTree>
          <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
            <stringProp name="CounterConfig.start">1</stringProp>
            <stringProp name="CounterConfig.end">1001</stringProp>
            <stringProp name="CounterConfig.incr">1</stringProp>
            <stringProp name="CounterConfig.name">loopCount</stringProp>
            <stringProp name="CounterConfig.format"></stringProp>
            <boolProp name="CounterConfig.per_user">false</boolProp>
          </CounterConfig>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="[AI] 监听需求制定并解析签名数据、任务规模、建议分支等" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="dataType">Text</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <stringProp name="readTimeout">60000</stringProp>
            <boolProp name="optional">false</boolProp>
          </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
          <hashTree>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="extract ping flag" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">is_ping</stringProp>
              <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">not_ping</stringProp>
              <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
            </RegexExtractor>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print ping flag" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;is_ping 的值: &quot; + is_ping);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="filter websocket ping frame and auto response" enabled="true">
              <boolProp name="replyToPing">true</boolProp>
              <stringProp name="filterType">FilterPingOnly</stringProp>
            </eu.luminis.jmeter.wssampler.PingFrameFilter>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="analyze specUpdate response" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;specUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 specUpdated 消息&quot;);
				 vars.put(&quot;monitorFlagSpecUpdated&quot;, &quot;specUpdated&quot;);
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="monitor socketio text ping event" enabled="true">
            <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="print log" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="response to socketio text ping" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="payloadType">TextStomp</stringProp>
              <stringProp name="requestData">3</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <boolProp name="loadDataFromFile">false</boolProp>
              <stringProp name="dataFile"></stringProp>
            </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="-&gt; [废弃] AI 规划和实现初始化需求" enabled="false"/>
        <hashTree>
          <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
            <boolProp name="TLS">true</boolProp>
            <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
            <stringProp name="port">443</stringProp>
            <stringProp name="path">/socket.io/?playgroundId=${issueThreadPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
            <stringProp name="connectTimeout">600000</stringProp>
            <stringProp name="readTimeout">900000</stringProp>
          </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
          <hashTree/>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; * AI wss 同步 playground 状态" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">3</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; * AI wss 获取 playground 状态" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss 制定用户需求（实现冒泡排序）" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;message&quot;,&quot;实现冒泡排序&quot;,false,true]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; * AI wss 监听制定用户需求（实现冒泡排序）" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">50</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; * AI wss 监听制定初始化环境需求结果" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">60000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;
import org.json.JSONObject;

// 获取原始响应字符串
responseData = prev.getResponseDataAsString();

// 提取状态码（假设格式为 &quot;430[{...}]&quot;）
statusCode = responseData.substring(0, responseData.indexOf(&quot;[&quot;));
jsonStr = responseData.substring(responseData.indexOf(&quot;[&quot;));

bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

// 仅当状态码为 430 时处理
if (statusCode.equals(&quot;430&quot;)) {
    try {
        // 解析 JSON 数组
        jsonArray = new JSONArray(jsonStr);
        
        if (jsonArray.length() &gt; 0) {
            // 提取第一个 environmentList 的第一个 id
            firstId = jsonArray.getJSONObject(0)
                             .getJSONObject(&quot;data&quot;)
                             .getJSONArray(&quot;environments&quot;)
                             .getJSONObject(0)
                             .getJSONArray(&quot;versionList&quot;)
                             .getJSONObject(0)
                             .getString(&quot;id&quot;);
            
            vars.put(&quot;firstEnvironmentFirstId&quot;, firstId);
            bsh.shared.util.info(&quot;✅ 提取成功: &quot; + firstId);
        }
    } catch (Exception e) {
        bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
    }
} else {
    log.warn(&quot;⏩ 状态码不是430&quot;);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 制定初始化环境计划" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">420[&quot;uMakePlan&quot;,&quot;Initialize the Development Environment&quot;,&quot;Follow instructions provided to initialize the development environment in Clacky&quot;,[&quot;Use Go environment to run the project with &apos;go run main.go&apos;&quot;,&quot;If package manager used in project, install it and use it to install dependencies for development.&quot;,&quot;Modify the .1024 file to configure the project and define the run_command. &quot;,&quot;Configure .gitignore file, excluding specified files and directories. &quot;,&quot;If database, redis used and *.example file exists, create env configuration files to add provided variables. &quot;]]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听指定初始化环境计划" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount2&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount2&quot;)) &lt; 1000 &amp;&amp; vars.get(&quot;planId&quot;) == null ),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount2</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="websocket 重连" enabled="true">
              <stringProp name="IfController.condition">${__javaScript(&quot;${RETRY}&quot;==&quot;true&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
                <boolProp name="TLS">true</boolProp>
                <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
                <stringProp name="port">443</stringProp>
                <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
                <stringProp name="connectTimeout">600000</stringProp>
                <stringProp name="readTimeout">900000</stringProp>
              </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 制定初始化环境计划" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">420[&quot;uMakePlan&quot;,&quot;Initialize the Development Environment&quot;,&quot;Follow instructions provided to initialize the development environment in Clacky&quot;,[&quot;Use Go environment to run the project with &apos;go run main.go&apos;&quot;,&quot;If package manager used in project, install it and use it to install dependencies for development.&quot;,&quot;Modify the .1024 file to configure the project and define the run_command. &quot;,&quot;Configure .gitignore file, excluding specified files and directories. &quot;,&quot;If database, redis used and *.example file exists, create env configuration files to add provided variables. &quot;]]</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听制定初始化环境计划" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析计划制定情况" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;
import org.json.JSONObject;

try {
    // 获取原始响应字符串
    responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
       
    }else{
// 提取状态码和JSON部分（假设格式为 &quot;42[\&quot;planUpdated\&quot;, {...}]&quot;）
    statusCode = responseData.substring(0, responseData.indexOf(&quot;[&quot;));
    jsonStr = responseData.substring(responseData.indexOf(&quot;[&quot;));
    
    bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

    // 仅当状态码为42且包含planUpdated时才处理
    if (statusCode.equals(&quot;42&quot;)) {
        try {
            // 解析JSON数组
            jsonArray = new JSONArray(jsonStr);
            
            // 检查第一个元素是否是&quot;planUpdated&quot;
            if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskPlanned&quot;.equals(jsonArray.getString(0))) {
                bsh.shared.util.info(&quot;✅ 检测到planUpdated消息&quot;);
                
                if (jsonArray.length() &gt; 1) {
                    // 获取任务数据对象
                    taskData = jsonArray.getJSONObject(1);

                    if (taskData.has(&quot;id&quot;)) {
				    // 存在 id 字段
				    vars.put(&quot;planId&quot;, &quot;1&quot;);
				} else {
				    // 不存在 id 字段
				    log.warn(&quot;⚠️ JSON 不包含 id 字段&quot;);
				}
                    
	           }
            } else {
                log.warn(&quot;⏩ 消息类型不是planUpdated&quot;);
            }
        } catch (Exception e) {
            bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
        }
    } else {
        log.warn(&quot;⏩ 状态码不是42&quot;);
    }

    	
    }
    
    
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">String code = prev.getResponseCode()

if ((code != null &amp;&amp; code.contains(&quot;error&quot;) &amp;&amp; code.contains(&quot;close&quot;) ) || code.contains(&quot;no connection&quot;) ) {
	 bsh.shared.util.info(&quot;====================重连&quot;)
        vars.put(&quot;RETRY&quot;, &quot;true&quot;)
   
} else {
    // 连接成功，不再重试
    vars.put(&quot;RETRY&quot;, &quot;false&quot;)
    bsh.shared.util.info(&quot;连接成功&quot;)
}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 执行任务" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;uStartTask&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听执行任务" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount3&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount3&quot;)) &lt; 100 &amp;&amp; vars.get(&quot;taskStatus&quot;) == null  || vars.get(&quot;taskStatus&quot;) !=&quot;done&quot;),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">101</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount3</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="websocket 重连" enabled="true">
              <stringProp name="IfController.condition">${__javaScript(&quot;${RETRY}&quot;==&quot;true&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
                <boolProp name="TLS">true</boolProp>
                <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
                <stringProp name="port">443</stringProp>
                <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
                <stringProp name="connectTimeout">600000</stringProp>
                <stringProp name="readTimeout">900000</stringProp>
              </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 执行任务" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">421[&quot;uStartTask&quot;]</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听执行任务" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析任务执行结果" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskStateUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 taskStateUpdated 消息&quot;);

                    // 第二个元素是任务状态
                    if (jsonArray.length() &gt; 1) {
                        String taskStatus = jsonArray.getString(1);
                        bsh.shared.util.info(&quot;🛠️ 任务状态: &quot; + taskStatus);

                        // 设置变量供后续使用
                        vars.put(&quot;taskStatus&quot;, taskStatus);
                    }
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">String code = prev.getResponseCode()

if ((code != null &amp;&amp; code.contains(&quot;error&quot;) &amp;&amp; code.contains(&quot;close&quot;) ) || code.contains(&quot;no connection&quot;)) {
	 bsh.shared.util.info(&quot;====================重连&quot;)
        vars.put(&quot;RETRY&quot;, &quot;true&quot;)
   
} else {
    // 连接成功，不再重试
    vars.put(&quot;RETRY&quot;, &quot;false&quot;)
    bsh.shared.util.info(&quot;连接成功&quot;)
}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 查看 commit 文件列表" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">423[&quot;uMakeCommitFileList&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; AI wss 监听查看 commit 文件列表" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">1</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听查看 commit 文件列表" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">6000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 获取 commit 信息" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">424[&quot;uMakeCommitMessage&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; AI wss 监听获取 commit 信息" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">1</stringProp>
          </LoopController>
          <hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听获取 commit 信息" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">6000</stringProp>
              <boolProp name="optional">false</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree/>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 发送新需求消息" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">420[&quot;message&quot;,&quot;实现冒泡算法&quot;,false,false]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听新需求消息处理情况" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount4&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount4&quot;)) &lt; 50 &amp;&amp; vars.get(&quot;addTaskStepConfirmation&quot;) == null),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount4</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="websocket 重连" enabled="true">
              <stringProp name="IfController.condition">${__javaScript(&quot;${RETRY}&quot;==&quot;true&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
                <boolProp name="TLS">true</boolProp>
                <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
                <stringProp name="port">443</stringProp>
                <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
                <stringProp name="connectTimeout">600000</stringProp>
                <stringProp name="readTimeout">900000</stringProp>
              </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 发送新需求消息" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">420[&quot;message&quot;,&quot;实现冒泡算法&quot;,false,false]</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听新需求消息处理" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析任务执行结果" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;addTaskStepConfirmation&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 addTaskStepConfirmation 消息&quot;);

                  
                   // 设置变量供后续使用
                   vars.put(&quot;addTaskStepConfirmation&quot;, &quot;true&quot;);
                   bsh.shared.util.info(&quot;✅✅ ✅ ✅ ✅  检测到 addTaskStepConfirmation 消息&quot;);
                    
                } else {
                    log.warn(&quot;⏩ 消息类型不是 addTaskStepConfirmation&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">String code = prev.getResponseCode()

if ((code != null &amp;&amp; code.contains(&quot;error&quot;) &amp;&amp; code.contains(&quot;close&quot;) ) || code.contains(&quot;no connection&quot;) ) {
	 bsh.shared.util.info(&quot;====================重连&quot;)
        vars.put(&quot;RETRY&quot;, &quot;true&quot;)
   
} else {
    // 连接成功，不再重试
    vars.put(&quot;RETRY&quot;, &quot;false&quot;)
    bsh.shared.util.info(&quot;连接成功&quot;)
}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 追加步骤" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">421[&quot;uAddStep&quot;,{&quot;title&quot;:&quot;Implement Bubble Sort Algorithm in main.go&quot;,&quot;task_actions&quot;:[{&quot;action&quot;:&quot;modify_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;main.go&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;- Modify the main.go file to add bubbleSort function that implements the bubble sort algorithm\n- Update the main function to create a sample integer array\n- Print the array before sorting\n- Call bubbleSort function to sort the array\n- Print the array after sorting\n- The bubbleSort function should:\n  - Accept an integer slice as input\n  - Implement the classic bubble sort algorithm by comparing adjacent elements\n  - Swap elements if they are in the wrong order\n  - Continue until the array is fully sorted&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;0&quot;}],&quot;merged&quot;:&quot;inited&quot;}]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听追加步骤情况" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount5&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount5&quot;)) &lt; 50 &amp;&amp; vars.get(&quot;addTaskStepStatus&quot;) == null),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">1001</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount5</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="websocket 重连" enabled="true">
              <stringProp name="IfController.condition">${__javaScript(&quot;${RETRY}&quot;==&quot;true&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
                <boolProp name="TLS">true</boolProp>
                <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
                <stringProp name="port">443</stringProp>
                <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
                <stringProp name="connectTimeout">600000</stringProp>
                <stringProp name="readTimeout">900000</stringProp>
              </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 追加步骤" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">421[&quot;uAddStep&quot;,{&quot;title&quot;:&quot;Implement Bubble Sort Algorithm in main.go&quot;,&quot;task_actions&quot;:[{&quot;action&quot;:&quot;modify_file&quot;,&quot;action_object&quot;:{&quot;path&quot;:&quot;main.go&quot;,&quot;target&quot;:&quot;&quot;,&quot;detailed_requirement&quot;:&quot;- Modify the main.go file to add bubbleSort function that implements the bubble sort algorithm\n- Update the main function to create a sample integer array\n- Print the array before sorting\n- Call bubbleSort function to sort the array\n- Print the array after sorting\n- The bubbleSort function should:\n  - Accept an integer slice as input\n  - Implement the classic bubble sort algorithm by comparing adjacent elements\n  - Swap elements if they are in the wrong order\n  - Continue until the array is fully sorted&quot;,&quot;references&quot;:[]},&quot;id&quot;:&quot;0&quot;}],&quot;merged&quot;:&quot;inited&quot;}]</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听追加步骤" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析任务执行结果" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;431&quot;.equals(statusCode)) {
           
                  
                        // 设置变量供后续使用
                        vars.put(&quot;addTaskStepStatus&quot;, &quot;true&quot;);
                    
              
        } else {
            log.warn(&quot;⏩ 状态码不是431&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">String code = prev.getResponseCode()

if ((code != null &amp;&amp; code.contains(&quot;error&quot;) &amp;&amp; code.contains(&quot;close&quot;) ) || code.contains(&quot;no connection&quot;)) {
	 bsh.shared.util.info(&quot;====================重连&quot;)
        vars.put(&quot;RETRY&quot;, &quot;true&quot;)
   
} else {
    // 连接成功，不再重试
    vars.put(&quot;RETRY&quot;, &quot;false&quot;)
    bsh.shared.util.info(&quot;连接成功&quot;)
}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 执行追加步骤任务" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="payloadType">Text</stringProp>
            <stringProp name="requestData">422[&quot;uStartTask&quot;]</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <boolProp name="loadDataFromFile">false</boolProp>
            <stringProp name="dataFile"></stringProp>
          </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
          <hashTree/>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; AI wss 监听追加步骤执行任务" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount6&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount6&quot;)) &lt; 100 &amp;&amp; vars.get(&quot;taskStatus&quot;) == null  || vars.get(&quot;taskStatus&quot;) !=&quot;done&quot;),)}</stringProp>
          </WhileController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">101</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">loopCount6</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="websocket 重连" enabled="true">
              <stringProp name="IfController.condition">${__javaScript(&quot;${RETRY}&quot;==&quot;true&quot;)}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
                <boolProp name="TLS">true</boolProp>
                <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
                <stringProp name="port">443</stringProp>
                <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
                <stringProp name="connectTimeout">600000</stringProp>
                <stringProp name="readTimeout">900000</stringProp>
              </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; AI wss 执行追加步骤任务" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="payloadType">Text</stringProp>
                <stringProp name="requestData">422[&quot;uStartTask&quot;]</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <boolProp name="loadDataFromFile">false</boolProp>
                <stringProp name="dataFile"></stringProp>
              </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; AI wss 监听追加步骤执行任务" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="dataType">Text</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <stringProp name="readTimeout">900000</stringProp>
              <boolProp name="optional">true</boolProp>
            </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析任务执行结果" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;

try {
    // 获取原始响应字符串
    String responseData = prev.getResponseDataAsString();

    // 检查响应是否为空或无效
    if (responseData == null || responseData.isEmpty()) {
        log.warn(&quot;⚠️ 响应数据为空，跳过处理&quot;);
    } else {
        bsh.shared.util.info(&quot;原始响应: &quot; + responseData);

        // 提取状态码部分（假设格式为 &quot;42[\&quot;taskStateUpdated\&quot;,\&quot;done\&quot;]&quot;）
        int bracketIndex = responseData.indexOf(&quot;[&quot;);
        if (bracketIndex == -1) {
            bsh.shared.util.error(&quot;❌ 未找到 JSON 数组起始符号 [&quot;);
            return;
        }

        String statusCode = responseData.substring(0, bracketIndex);
        String jsonArrayStr = responseData.substring(bracketIndex);

        bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

        // 仅当状态码为42时处理
        if (&quot;42&quot;.equals(statusCode)) {
            try {
                // 解析JSON数组
                JSONArray jsonArray = new JSONArray(jsonArrayStr);

                // 检查第一个元素是否是 &quot;taskStateUpdated&quot;
                if (jsonArray.length() &gt; 0 &amp;&amp; &quot;taskStateUpdated&quot;.equals(jsonArray.getString(0))) {
                    bsh.shared.util.info(&quot;✅ 检测到 taskStateUpdated 消息&quot;);

                    // 第二个元素是任务状态
                    if (jsonArray.length() &gt; 1) {
                        String taskStatus = jsonArray.getString(1);
                        bsh.shared.util.info(&quot;🛠️ 任务状态: &quot; + taskStatus);

                        // 设置变量供后续使用
                        vars.put(&quot;taskStatus&quot;, taskStatus);
                    }
                } else {
                    log.warn(&quot;⏩ 消息类型不是 taskStateUpdated&quot;);
                }
            } catch (Exception e) {
                bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
            }
        } else {
            log.warn(&quot;⏩ 状态码不是42&quot;);
        }
    }
} catch (Exception e) {
    bsh.shared.util.error(&quot;❌ 处理响应数据时出错&quot;, e);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 PostProcessor" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">String code = prev.getResponseCode()

if ((code != null &amp;&amp; code.contains(&quot;error&quot;) &amp;&amp; code.contains(&quot;close&quot;) ) || code.contains(&quot;no connection&quot;)) {
	 bsh.shared.util.info(&quot;====================重连&quot;)
        vars.put(&quot;RETRY&quot;, &quot;true&quot;)
   
} else {
    // 连接成功，不再重试
    vars.put(&quot;RETRY&quot;, &quot;false&quot;)
    bsh.shared.util.info(&quot;连接成功&quot;)
}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="-&gt; AI wss close" enabled="true">
            <stringProp name="statusCode">1000</stringProp>
            <stringProp name="readTimeout">6000</stringProp>
          </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
          <hashTree/>
        </hashTree>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; check commit task" enabled="false">
          <stringProp name="WhileController.condition">${__javaScript(&quot;${checkCommitStatus}&quot; != &quot;2&quot; &amp;&amp; &quot;${checkCommitStatus}&quot; != &quot;3&quot;)}</stringProp>
        </WhileController>
        <hashTree>
          <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="1 秒定时器" enabled="true">
            <stringProp name="ConstantTimer.delay">1000</stringProp>
          </ConstantTimer>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; backend git check commit" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread/git-check?cmd_id=${commit_cmd_id}</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Thread-ID</stringProp>
                  <stringProp name="Header.value">${issueThreadId}</stringProp>
                </elementProp>
                <elementProp name="Content-Type" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析异步commit status" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;check commit 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

String checkCommitMsg = jsonObject.getString(&quot;msg&quot;);
bsh.shared.util.info(&quot;post process checkCommitMsg 的值: &quot; + checkCommitMsg);
bsh.shared.util.info(&quot;post process code 的值: &quot; + jsonObject.getInt(&quot;code&quot;));

// 如果 msg = Succeed，则获取 data 对象里面的 status 值添加到 vars 中
if(&quot;Succeed&quot;.equals(checkCommitMsg)){
	// 获取 data JSONObject
	JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
	// 获取 id 值 (threadId)
	int checkCommitStatus = data.getInt(&quot;status&quot;);
	String checkCommitStatusString = String.valueOf(checkCommitStatus);
	
	bsh.shared.util.info(&quot;post process checkCommitStatus 的值: &quot; + checkCommitStatusString);
	// 将 id 值设置为 JMeter 变量
	vars.put(&quot;checkCommitStatus&quot;, checkCommitStatusString);
}







</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
        </hashTree>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="check push task" enabled="false">
          <stringProp name="WhileController.condition">${__javaScript(&quot;${checkPushStatus}&quot; != &quot;2&quot; &amp;&amp; &quot;${checkPushStatus}&quot; != &quot;3&quot;)}</stringProp>
        </WhileController>
        <hashTree>
          <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="1 秒定时器" enabled="true">
            <stringProp name="ConstantTimer.delay">1000</stringProp>
          </ConstantTimer>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[Backend] push /thread/git-check [复用接口]" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread/git-check?cmd_id=${push_cmd_id}</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Thread-ID</stringProp>
                  <stringProp name="Header.value">${issueThreadId}</stringProp>
                </elementProp>
                <elementProp name="Content-Type" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析异步push status" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;check commit 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

String checkPushMsg = jsonObject.getString(&quot;msg&quot;);
bsh.shared.util.info(&quot;post process checkPushMsg 的值: &quot; + checkPushMsg);
bsh.shared.util.info(&quot;post process code 的值: &quot; + jsonObject.getInt(&quot;code&quot;));

// 如果 msg = Succeed，则获取 data 对象里面的 status 值添加到 vars 中
if(&quot;Succeed&quot;.equals(checkPushMsg)){
	// 获取 data JSONObject
	JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);
	// 获取 id 值 (threadId)
	int checkPushStatus = data.getInt(&quot;status&quot;);
	String checkPushStatusString = String.valueOf(checkPushStatus);
	
	bsh.shared.util.info(&quot;post process checkPushStatus 的值: &quot; + checkPushStatusString);
	// 将 id 值设置为 JMeter 变量
	vars.put(&quot;checkPushStatus&quot;, checkPushStatusString);
}







</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="覆盖其他主要业务流程" enabled="false"/>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend create project" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/project</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;name&quot;: &quot;test_project_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;,&#xd;
    &quot;repository_id&quot;: &quot;${repositoryId}&quot;,&#xd;
    &quot;branch&quot;: &quot;main&quot;,&#xd;
    &quot;visibility&quot;: &quot;PUBLIC&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析projectId 变量" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

// 获取 data JSONObject
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

// 获取 id 值 (projectId)
String projectId = data.getString(&quot;id&quot;);

bsh.shared.util.info(&quot;post process id 的值: &quot; + projectId);

// 将 id 值设置为 JMeter 变量
vars.put(&quot;projectId&quot;, projectId);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend create rootThread" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
	&quot;name&quot;: &quot;test_root_thread_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;,&#xd;
	&quot;issue&quot;: &quot;{\&quot;goal\&quot;:\&quot;Initialize the Development Environment\&quot;,\&quot;goal_detail\&quot;:\&quot;Follow instructions provided to initialize the development environment in Clacky\&quot;,\&quot;current_list\&quot;:[\&quot;The current project development environment has not yet completed the initialization steps\&quot;,\&quot;not yet installing project dependencies\&quot;,\&quot;not yet configuring project run_command and parameters\&quot;,\&quot;missing environment variable configuration files\&quot;,\&quot;missing .gitignore file and configuring the files to be ignored\&quot;],\&quot;proposed_list\&quot;:[\&quot;Use the Go 1.23 environment which is already installed: `gvm use go1.23`\&quot;,\&quot;If package manager used in project, install it and use it to install dependencies for development.\&quot;,\&quot;Modify the `.1024` file to configure the project and define the run_command. \&quot;,\&quot;Configure .gitignore file, excluding specified files and directories. \&quot;,\&quot;If database, redis used and `*.example` file exists, create env configuration files to add provided variables. \&quot;]}&quot;,&#xd;
	&quot;branch&quot;:&quot;setup_branch_${__time(yyyyMMddHHmm,)}_${__threadNum}&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析 threadId &amp;&amp; rootBranch" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;create rootThread 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

// 获取 data JSONObject
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

// 获取 id 值 (threadId)
String threadId = data.getString(&quot;id&quot;);

String rootBranch = data.getString(&quot;branch&quot;);


bsh.shared.util.info(&quot;post process threadId 的值: &quot; + threadId);

bsh.shared.util.info(&quot;post process rootBranch 的值: &quot; + rootBranch);

// 将 id 值设置为 JMeter 变量
vars.put(&quot;threadId&quot;, threadId);
vars.put(&quot;rootBranch&quot;, rootBranch);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend aysnc clone" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread/asyncClone</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;purpose&quot;:&quot;2-stress-test&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Thread-ID</stringProp>
                  <stringProp name="Header.value">${threadId}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析 clone_task_id &amp; rootThreadCodezoneId" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;async clone 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

// 获取 data JSONObject
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

// 获取 id 值 (threadId)
String clone_task_id = data.getString(&quot;clone_task_id&quot;);
String rootThreadCodezoneId = data.getString(&quot;codezone_id&quot;);

bsh.shared.util.info(&quot;post process clone_task_id 的值: &quot; + clone_task_id);
bsh.shared.util.info(&quot;post process rootThreadCodezoneId 的值: &quot; + rootThreadCodezoneId);

// 将 id 值设置为 JMeter 变量
vars.put(&quot;clone_task_id&quot;, clone_task_id);
vars.put(&quot;rootThreadCodezoneId&quot;, rootThreadCodezoneId);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; * backend 循环每 3 秒检查克隆状态" enabled="true">
            <stringProp name="WhileController.condition">${__javaScript(&quot;${clone_check_msg}&quot; != &quot;Succeed&quot; || &quot;${clone_check_progress}&quot; != &quot;COMPLETED&quot;)}</stringProp>
          </WhileController>
          <hashTree>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="wait one second timer" enabled="true">
              <stringProp name="ConstantTimer.delay">3000</stringProp>
            </ConstantTimer>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend check clone status" enabled="true">
              <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
              <stringProp name="HTTPSampler.protocol">https</stringProp>
              <stringProp name="HTTPSampler.path">/thread/import/check?task_id=${clone_task_id}</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">&#xd;
</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Project-ID</stringProp>
                    <stringProp name="Header.value">${projectId}</stringProp>
                  </elementProp>
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Thread-ID</stringProp>
                    <stringProp name="Header.value">${threadId}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String clone_task_id = vars.get(&quot;clone_task_id&quot;);
bsh.shared.util.info(&quot;pre process clone_task_id 的值: &quot; + clone_task_id);</stringProp>
              </BeanShellPreProcessor>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="解析异步克隆结果" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONObject;

// 获取响应数据
String jsonResult = prev.getResponseDataAsString();

bsh.shared.util.info(&quot;check clone 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

// 创建 JSONObject
JSONObject jsonObject = new JSONObject(jsonResult);

String clone_check_msg = jsonObject.getString(&quot;msg&quot;);

// 获取 data 对象
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

// 获取 data 对象中的 progress 字段
    String progress = data.getString(&quot;progress&quot;);

    bsh.shared.util.info(&quot;clone_check_progress 的值: &quot; + progress);

    // 将 code 和 msg 值设置为 JMeter 变量
    vars.put(&quot;clone_check_progress&quot;, progress);



bsh.shared.util.info(&quot;post process clone_check_msg 的值: &quot; + clone_check_msg);

// 将 id 值设置为 JMeter 变量
vars.put(&quot;clone_check_msg&quot;, clone_check_msg);</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas 创建 rootPlayground" enabled="true">
            <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/${rootThreadCodezoneId}/playground</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.json.*;

String jsonResult = prev.getResponseDataAsString();


bsh.shared.util.info(&quot;rootPlayground create 接口返回===============&gt;&gt;&gt;&gt;&quot;+jsonResult);

JSONObject jsonObject = new JSONObject(jsonResult); 
 
JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);

String da1 = data.getString(&quot;id&quot;);

vars.put(&quot;rootPlaygroundId&quot;, da1);

bsh.shared.util.info(&quot;rootPlaygroundId 的值: &quot; + da1);
</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="[新增] [PaaS] 获取环境版本列表" enabled="true">
            <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/api/v1/sdk/environments</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="-&gt; * 连接 AiAgent 分析项目代码" enabled="true"/>
          <hashTree>
            <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="-&gt; * AI wss 连接 agent" enabled="true">
              <boolProp name="TLS">true</boolProp>
              <stringProp name="server">${WSS_AGENT_DOMAIN}</stringProp>
              <stringProp name="port">443</stringProp>
              <stringProp name="path">/socket.io/?playgroundId=${rootPlaygroundId}&amp;EIO=4&amp;transport=websocket</stringProp>
              <stringProp name="connectTimeout">300000</stringProp>
              <stringProp name="readTimeout">60000</stringProp>
            </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss isRoot" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="payloadType">Text</stringProp>
              <stringProp name="requestData">40{&quot;isRoot&quot;:true}</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <boolProp name="loadDataFromFile">false</boolProp>
              <stringProp name="dataFile"></stringProp>
            </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
            <hashTree/>
            <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="-&gt; * AI wss 循环接收 agent 消息" enabled="true">
              <boolProp name="LoopController.continue_forever">true</boolProp>
              <stringProp name="LoopController.loops">3</stringProp>
            </LoopController>
            <hashTree>
              <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; * AI wss 接收消息" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="dataType">Text</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <stringProp name="readTimeout">60000</stringProp>
                <boolProp name="optional">false</boolProp>
              </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="-&gt; * AI wss 分析项目代码" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="payloadType">Text</stringProp>
              <stringProp name="requestData">420[&quot;uAnalyzeProjectEnvironment&quot;]</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <boolProp name="loadDataFromFile">false</boolProp>
              <stringProp name="dataFile"></stringProp>
            </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
            <hashTree/>
            <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="-&gt; * AI wss 循环监听分析项目代码响应事件获取 环境版本ID " enabled="true">
              <stringProp name="WhileController.condition">${__javaScript(  vars.get(&quot;loopCount&quot;) == null ||  ( parseInt(vars.get(&quot;loopCount&quot;)) &lt; 20 &amp;&amp; vars.get(&quot;firstEnvironmentFirstId&quot;) == null ),)}</stringProp>
            </WhileController>
            <hashTree>
              <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="计数器" enabled="true">
                <stringProp name="CounterConfig.start">1</stringProp>
                <stringProp name="CounterConfig.end">21</stringProp>
                <stringProp name="CounterConfig.incr">1</stringProp>
                <stringProp name="CounterConfig.name">loopCount</stringProp>
                <stringProp name="CounterConfig.format"></stringProp>
                <boolProp name="CounterConfig.per_user">false</boolProp>
              </CounterConfig>
              <hashTree/>
              <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="-&gt; * AI wss 监听分析项目代码响应事件" enabled="true">
                <boolProp name="TLS">false</boolProp>
                <stringProp name="server"></stringProp>
                <stringProp name="port">80</stringProp>
                <stringProp name="path"></stringProp>
                <stringProp name="connectTimeout">20000</stringProp>
                <stringProp name="dataType">Text</stringProp>
                <boolProp name="createNewConnection">false</boolProp>
                <stringProp name="readTimeout">12000</stringProp>
                <boolProp name="optional">false</boolProp>
              </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
              <hashTree/>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="获取环境版本ID和名称" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">import org.json.JSONArray;
import org.json.JSONObject;

try {
    int loopCountVar = Integer.parseInt(vars.get(&quot;loopCount&quot;));
    if (loopCountVar &gt; 20 ) {
        bsh.shared.util.info(&quot;Variable value is greater than 20. Stopping thread.&quot;);
        sampler.getThreadContext().getThread().stop();
    }
} catch (NumberFormatException e) {
    bsh.shared.util.error(&quot;Error parsing variable value: &quot; + e.getMessage());
} catch (NullPointerException e) {
    bsh.shared.util.error(&quot;Variable not found: &quot; + e.getMessage());
}

// 获取原始响应字符串
responseData = prev.getResponseDataAsString();

// 提取状态码（假设格式为 &quot;430[{...}]&quot;）
statusCode = responseData.substring(0, responseData.indexOf(&quot;[&quot;));
jsonStr = responseData.substring(responseData.indexOf(&quot;[&quot;));

bsh.shared.util.info(&quot;状态码: &quot; + statusCode);  // 打印调试

// 仅当状态码为 430 时处理
if (statusCode.equals(&quot;430&quot;)) {
    try {
        // 解析 JSON 数组
        jsonArray = new JSONArray(jsonStr);
        
        if (jsonArray.length() &gt; 0) {
            // 提取第一个 environmentList 的第一个 id
            firstId = jsonArray.getJSONObject(0)
                             .getJSONObject(&quot;data&quot;)
                             .getJSONArray(&quot;environments&quot;)
                             .getJSONObject(0)
                             .getJSONArray(&quot;versionList&quot;)
                             .getJSONObject(0)
                             .getString(&quot;id&quot;);

             firstName = jsonArray.getJSONObject(0)
                             .getJSONObject(&quot;data&quot;)
                             .getJSONArray(&quot;environments&quot;)
                             .getJSONObject(0)
                             .getJSONArray(&quot;versionList&quot;)
                             .getJSONObject(0)
                             .getString(&quot;name&quot;);
                            
            
            vars.put(&quot;firstEnvironmentFirstId&quot;, firstId);
            vars.put(&quot;firstEnvironmentFirstName&quot;, firstName);
            bsh.shared.util.info(&quot;✅ 提取成功: &quot; + firstId);
            bsh.shared.util.info(&quot;✅ 提取成功: &quot; + firstName);
        }
    } catch (Exception e) {
        bsh.shared.util.error(&quot;❌ JSON解析失败&quot;, e);
    }
} else {
    log.warn(&quot;⏩ 状态码不是430&quot;);
}</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="-&gt; AI wss close" enabled="true">
              <stringProp name="statusCode">1000</stringProp>
              <stringProp name="readTimeout">6000</stringProp>
            </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * paas upgrade codezone" enabled="true">
            <stringProp name="HTTPSampler.domain">${PAAS_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/api/v1/sdk/codeZones/${rootThreadCodezoneId}/upgrade</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;environmentVerId&quot;: &quot;${firstEnvironmentFirstId}&quot;,&#xd;
  &quot;unitTestFrameworkId&quot;: &quot;&quot;,&#xd;
  &quot;purpose&quot;: &quot;2-stress-test&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; * backend update rootThread 环境名称" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;type&quot;:&quot;${firstEnvironmentFirstName}&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Thread-ID</stringProp>
                  <stringProp name="Header.value">${threadId}</stringProp>
                </elementProp>
                <elementProp name="Content-Type" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="-&gt; 日志检查codezoneId 的值" enabled="true">
            <stringProp name="BeanShellSampler.query">// BeanShell Sampler
String codezoneId = vars.get(&quot;codezoneId&quot;);
bsh.shared.util.info(&quot;codezoneId 的值: &quot; + codezoneId);</stringProp>
          </BeanShellSampler>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="-&gt; backend close rootThread" enabled="true">
            <stringProp name="HTTPSampler.domain">${BACKEND_DOMAIN}</stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.path">/thread/close</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Project-ID</stringProp>
                  <stringProp name="Header.value">${projectId}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Thread-ID</stringProp>
                  <stringProp name="Header.value">${threadId}</stringProp>
                </elementProp>
                <elementProp name="Content-Type" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
        </hashTree>
        <eu.luminis.jmeter.wssampler.OpenWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.OpenWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.OpenWebSocketSampler" testname="WebSocket Open Connection" enabled="false">
          <boolProp name="TLS">false</boolProp>
          <stringProp name="server">127.0.0.1</stringProp>
          <stringProp name="port">3020</stringProp>
          <stringProp name="path">/socket.io/?EIO=4&amp;transport=websocket</stringProp>
          <stringProp name="connectTimeout">20000</stringProp>
          <stringProp name="readTimeout">6000</stringProp>
        </eu.luminis.jmeter.wssampler.OpenWebSocketSampler>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="false">
          <stringProp name="LoopController.loops">5</stringProp>
        </LoopController>
        <hashTree>
          <eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler" testname="WebSocket Single Read Sampler" enabled="true">
            <boolProp name="TLS">false</boolProp>
            <stringProp name="server"></stringProp>
            <stringProp name="port">80</stringProp>
            <stringProp name="path"></stringProp>
            <stringProp name="connectTimeout">20000</stringProp>
            <stringProp name="dataType">Text</stringProp>
            <boolProp name="createNewConnection">false</boolProp>
            <stringProp name="readTimeout">600000</stringProp>
            <boolProp name="optional">false</boolProp>
          </eu.luminis.jmeter.wssampler.SingleReadWebSocketSampler>
          <hashTree>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="is_ping" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">is_ping</stringProp>
              <stringProp name="RegexExtractor.regex">(\d+)</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default">not_ping</stringProp>
              <boolProp name="RegexExtractor.default_empty_value">false</boolProp>
              <stringProp name="RegexExtractor.match_number">1</stringProp>
            </RegexExtractor>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;is_ping 的值: &quot; + is_ping);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.PingFrameFilter guiclass="eu.luminis.jmeter.wssampler.PingFrameFilterGui" testclass="eu.luminis.jmeter.wssampler.PingFrameFilter" testname="WebSocket Ping/Pong Frame Filter" enabled="true">
              <boolProp name="replyToPing">true</boolProp>
              <stringProp name="filterType">FilterPingOnly</stringProp>
            </eu.luminis.jmeter.wssampler.PingFrameFilter>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings"/>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">16</intProp>
            </ResponseAssertion>
            <hashTree/>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
            <stringProp name="IfController.condition">${__jexl3(&quot;${is_ping}&quot; == &quot;2&quot;)}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">String is_ping = vars.get(&quot;is_ping&quot;);
bsh.shared.util.info(&quot;if controller 解析到 is_ping 的值: &quot; + is_ping);</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
            <eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler" testname="WebSocket Single Write Sampler" enabled="true">
              <boolProp name="TLS">false</boolProp>
              <stringProp name="server"></stringProp>
              <stringProp name="port">80</stringProp>
              <stringProp name="path"></stringProp>
              <stringProp name="connectTimeout">20000</stringProp>
              <stringProp name="payloadType">TextStomp</stringProp>
              <stringProp name="requestData">3</stringProp>
              <boolProp name="createNewConnection">false</boolProp>
              <boolProp name="loadDataFromFile">false</boolProp>
              <stringProp name="dataFile"></stringProp>
            </eu.luminis.jmeter.wssampler.SingleWriteWebSocketSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <eu.luminis.jmeter.wssampler.CloseWebSocketSampler guiclass="eu.luminis.jmeter.wssampler.CloseWebSocketSamplerGui" testclass="eu.luminis.jmeter.wssampler.CloseWebSocketSampler" testname="WebSocket Close" enabled="false">
          <stringProp name="statusCode">1000</stringProp>
          <stringProp name="readTimeout">6000</stringProp>
        </eu.luminis.jmeter.wssampler.CloseWebSocketSampler>
        <hashTree/>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="SimpleDataWriter" testclass="ResultCollector" testname="Simple Data Writer" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename">D:\zjtc\stress_test\clackyai_system_test\result.jtl</stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
